{
  "language": "Solidity",
  "sources": {
    "@aave/core-v3/contracts/interfaces/ICreditDelegationToken.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\n/**\n * @title ICreditDelegationToken\n * @author Aave\n * @notice Defines the basic interface for a token supporting credit delegation.\n */\ninterface ICreditDelegationToken {\n  /**\n   * @dev Emitted on `approveDelegation` and `borrowAllowance\n   * @param fromUser The address of the delegator\n   * @param toUser The address of the delegatee\n   * @param asset The address of the delegated asset\n   * @param amount The amount being delegated\n   */\n  event BorrowAllowanceDelegated(\n    address indexed fromUser,\n    address indexed toUser,\n    address indexed asset,\n    uint256 amount\n  );\n\n  /**\n   * @notice Delegates borrowing power to a user on the specific debt token.\n   * Delegation will still respect the liquidation constraints (even if delegated, a\n   * delegatee cannot force a delegator HF to go below 1)\n   * @param delegatee The address receiving the delegated borrowing power\n   * @param amount The maximum amount being delegated.\n   */\n  function approveDelegation(address delegatee, uint256 amount) external;\n\n  /**\n   * @notice Returns the borrow allowance of the user\n   * @param fromUser The user to giving allowance\n   * @param toUser The user to give allowance to\n   * @return The current allowance of `toUser`\n   */\n  function borrowAllowance(address fromUser, address toUser) external view returns (uint256);\n\n  /**\n   * @notice Delegates borrowing power to a user on the specific debt token via ERC712 signature\n   * @param delegator The delegator of the credit\n   * @param delegatee The delegatee that can use the credit\n   * @param value The amount to be delegated\n   * @param deadline The deadline timestamp, type(uint256).max for max deadline\n   * @param v The V signature param\n   * @param s The S signature param\n   * @param r The R signature param\n   */\n  function delegationWithSig(\n    address delegator,\n    address delegatee,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n}\n"
    },
    "@aave/core-v3/contracts/interfaces/IPool.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport {IPoolAddressesProvider} from './IPoolAddressesProvider.sol';\nimport {DataTypes} from '../protocol/libraries/types/DataTypes.sol';\n\n/**\n * @title IPool\n * @author Aave\n * @notice Defines the basic interface for an Aave Pool.\n */\ninterface IPool {\n  /**\n   * @dev Emitted on mintUnbacked()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address initiating the supply\n   * @param onBehalfOf The beneficiary of the supplied assets, receiving the aTokens\n   * @param amount The amount of supplied assets\n   * @param referralCode The referral code used\n   */\n  event MintUnbacked(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted on backUnbacked()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param backer The address paying for the backing\n   * @param amount The amount added as backing\n   * @param fee The amount paid in fees\n   */\n  event BackUnbacked(address indexed reserve, address indexed backer, uint256 amount, uint256 fee);\n\n  /**\n   * @dev Emitted on supply()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address initiating the supply\n   * @param onBehalfOf The beneficiary of the supply, receiving the aTokens\n   * @param amount The amount supplied\n   * @param referralCode The referral code used\n   */\n  event Supply(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted on withdraw()\n   * @param reserve The address of the underlying asset being withdrawn\n   * @param user The address initiating the withdrawal, owner of aTokens\n   * @param to The address that will receive the underlying\n   * @param amount The amount to be withdrawn\n   */\n  event Withdraw(address indexed reserve, address indexed user, address indexed to, uint256 amount);\n\n  /**\n   * @dev Emitted on borrow() and flashLoan() when debt needs to be opened\n   * @param reserve The address of the underlying asset being borrowed\n   * @param user The address of the user initiating the borrow(), receiving the funds on borrow() or just\n   * initiator of the transaction on flashLoan()\n   * @param onBehalfOf The address that will be getting the debt\n   * @param amount The amount borrowed out\n   * @param interestRateMode The rate mode: 1 for Stable, 2 for Variable\n   * @param borrowRate The numeric rate at which the user has borrowed, expressed in ray\n   * @param referralCode The referral code used\n   */\n  event Borrow(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    DataTypes.InterestRateMode interestRateMode,\n    uint256 borrowRate,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted on repay()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The beneficiary of the repayment, getting his debt reduced\n   * @param repayer The address of the user initiating the repay(), providing the funds\n   * @param amount The amount repaid\n   * @param useATokens True if the repayment is done using aTokens, `false` if done with underlying asset directly\n   */\n  event Repay(\n    address indexed reserve,\n    address indexed user,\n    address indexed repayer,\n    uint256 amount,\n    bool useATokens\n  );\n\n  /**\n   * @dev Emitted on swapBorrowRateMode()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user swapping his rate mode\n   * @param interestRateMode The current interest rate mode of the position being swapped: 1 for Stable, 2 for Variable\n   */\n  event SwapBorrowRateMode(\n    address indexed reserve,\n    address indexed user,\n    DataTypes.InterestRateMode interestRateMode\n  );\n\n  /**\n   * @dev Emitted on borrow(), repay() and liquidationCall() when using isolated assets\n   * @param asset The address of the underlying asset of the reserve\n   * @param totalDebt The total isolation mode debt for the reserve\n   */\n  event IsolationModeTotalDebtUpdated(address indexed asset, uint256 totalDebt);\n\n  /**\n   * @dev Emitted when the user selects a certain asset category for eMode\n   * @param user The address of the user\n   * @param categoryId The category id\n   */\n  event UserEModeSet(address indexed user, uint8 categoryId);\n\n  /**\n   * @dev Emitted on setUserUseReserveAsCollateral()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user enabling the usage as collateral\n   */\n  event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on setUserUseReserveAsCollateral()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user enabling the usage as collateral\n   */\n  event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on rebalanceStableBorrowRate()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user for which the rebalance has been executed\n   */\n  event RebalanceStableBorrowRate(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on flashLoan()\n   * @param target The address of the flash loan receiver contract\n   * @param initiator The address initiating the flash loan\n   * @param asset The address of the asset being flash borrowed\n   * @param amount The amount flash borrowed\n   * @param interestRateMode The flashloan mode: 0 for regular flashloan, 1 for Stable debt, 2 for Variable debt\n   * @param premium The fee flash borrowed\n   * @param referralCode The referral code used\n   */\n  event FlashLoan(\n    address indexed target,\n    address initiator,\n    address indexed asset,\n    uint256 amount,\n    DataTypes.InterestRateMode interestRateMode,\n    uint256 premium,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted when a borrower is liquidated.\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n   * @param user The address of the borrower getting liquidated\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n   * @param liquidatedCollateralAmount The amount of collateral received by the liquidator\n   * @param liquidator The address of the liquidator\n   * @param receiveAToken True if the liquidators wants to receive the collateral aTokens, `false` if he wants\n   * to receive the underlying collateral asset directly\n   */\n  event LiquidationCall(\n    address indexed collateralAsset,\n    address indexed debtAsset,\n    address indexed user,\n    uint256 debtToCover,\n    uint256 liquidatedCollateralAmount,\n    address liquidator,\n    bool receiveAToken\n  );\n\n  /**\n   * @dev Emitted when the state of a reserve is updated.\n   * @param reserve The address of the underlying asset of the reserve\n   * @param liquidityRate The next liquidity rate\n   * @param stableBorrowRate The next stable borrow rate\n   * @param variableBorrowRate The next variable borrow rate\n   * @param liquidityIndex The next liquidity index\n   * @param variableBorrowIndex The next variable borrow index\n   */\n  event ReserveDataUpdated(\n    address indexed reserve,\n    uint256 liquidityRate,\n    uint256 stableBorrowRate,\n    uint256 variableBorrowRate,\n    uint256 liquidityIndex,\n    uint256 variableBorrowIndex\n  );\n\n  /**\n   * @dev Emitted when the protocol treasury receives minted aTokens from the accrued interest.\n   * @param reserve The address of the reserve\n   * @param amountMinted The amount minted to the treasury\n   */\n  event MintedToTreasury(address indexed reserve, uint256 amountMinted);\n\n  /**\n   * @notice Mints an `amount` of aTokens to the `onBehalfOf`\n   * @param asset The address of the underlying asset to mint\n   * @param amount The amount to mint\n   * @param onBehalfOf The address that will receive the aTokens\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function mintUnbacked(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @notice Back the current unbacked underlying with `amount` and pay `fee`.\n   * @param asset The address of the underlying asset to back\n   * @param amount The amount to back\n   * @param fee The amount paid in fees\n   * @return The backed amount\n   */\n  function backUnbacked(address asset, uint256 amount, uint256 fee) external returns (uint256);\n\n  /**\n   * @notice Supplies an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n   * - E.g. User supplies 100 USDC and gets in return 100 aUSDC\n   * @param asset The address of the underlying asset to supply\n   * @param amount The amount to be supplied\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n   *   is a different wallet\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function supply(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) external;\n\n  /**\n   * @notice Supply with transfer approval of asset to be supplied done via permit function\n   * see: https://eips.ethereum.org/EIPS/eip-2612 and https://eips.ethereum.org/EIPS/eip-713\n   * @param asset The address of the underlying asset to supply\n   * @param amount The amount to be supplied\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n   *   is a different wallet\n   * @param deadline The deadline timestamp that the permit is valid\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   * @param permitV The V parameter of ERC712 permit sig\n   * @param permitR The R parameter of ERC712 permit sig\n   * @param permitS The S parameter of ERC712 permit sig\n   */\n  function supplyWithPermit(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode,\n    uint256 deadline,\n    uint8 permitV,\n    bytes32 permitR,\n    bytes32 permitS\n  ) external;\n\n  /**\n   * @notice Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\n   * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\n   * @param asset The address of the underlying asset to withdraw\n   * @param amount The underlying amount to be withdrawn\n   *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\n   * @param to The address that will receive the underlying, same as msg.sender if the user\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n   *   different wallet\n   * @return The final amount withdrawn\n   */\n  function withdraw(address asset, uint256 amount, address to) external returns (uint256);\n\n  /**\n   * @notice Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\n   * already supplied enough collateral, or he was given enough allowance by a credit delegator on the\n   * corresponding debt token (StableDebtToken or VariableDebtToken)\n   * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\n   *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\n   * @param asset The address of the underlying asset to borrow\n   * @param amount The amount to be borrowed\n   * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\n   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   * @param onBehalfOf The address of the user who will receive the debt. Should be the address of the borrower itself\n   * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\n   * if he has been given credit delegation allowance\n   */\n  function borrow(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode,\n    uint16 referralCode,\n    address onBehalfOf\n  ) external;\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\n   * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\n   * @param asset The address of the borrowed underlying asset previously borrowed\n   * @param amount The amount to repay\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n   * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n   * @param onBehalfOf The address of the user who will get his debt reduced/removed. Should be the address of the\n   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n   * other borrower whose debt should be removed\n   * @return The final amount repaid\n   */\n  function repay(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode,\n    address onBehalfOf\n  ) external returns (uint256);\n\n  /**\n   * @notice Repay with transfer approval of asset to be repaid done via permit function\n   * see: https://eips.ethereum.org/EIPS/eip-2612 and https://eips.ethereum.org/EIPS/eip-713\n   * @param asset The address of the borrowed underlying asset previously borrowed\n   * @param amount The amount to repay\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n   * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n   * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\n   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n   * other borrower whose debt should be removed\n   * @param deadline The deadline timestamp that the permit is valid\n   * @param permitV The V parameter of ERC712 permit sig\n   * @param permitR The R parameter of ERC712 permit sig\n   * @param permitS The S parameter of ERC712 permit sig\n   * @return The final amount repaid\n   */\n  function repayWithPermit(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode,\n    address onBehalfOf,\n    uint256 deadline,\n    uint8 permitV,\n    bytes32 permitR,\n    bytes32 permitS\n  ) external returns (uint256);\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific reserve using the reserve aTokens, burning the\n   * equivalent debt tokens\n   * - E.g. User repays 100 USDC using 100 aUSDC, burning 100 variable/stable debt tokens\n   * @dev  Passing uint256.max as amount will clean up any residual aToken dust balance, if the user aToken\n   * balance is not enough to cover the whole debt\n   * @param asset The address of the borrowed underlying asset previously borrowed\n   * @param amount The amount to repay\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n   * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n   * @return The final amount repaid\n   */\n  function repayWithATokens(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode\n  ) external returns (uint256);\n\n  /**\n   * @notice Allows a borrower to swap his debt between stable and variable mode, or vice versa\n   * @param asset The address of the underlying asset borrowed\n   * @param interestRateMode The current interest rate mode of the position being swapped: 1 for Stable, 2 for Variable\n   */\n  function swapBorrowRateMode(address asset, uint256 interestRateMode) external;\n\n  /**\n   * @notice Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.\n   * - Users can be rebalanced if the following conditions are satisfied:\n   *     1. Usage ratio is above 95%\n   *     2. the current supply APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too\n   *        much has been borrowed at a stable rate and suppliers are not earning enough\n   * @param asset The address of the underlying asset borrowed\n   * @param user The address of the user to be rebalanced\n   */\n  function rebalanceStableBorrowRate(address asset, address user) external;\n\n  /**\n   * @notice Allows suppliers to enable/disable a specific supplied asset as collateral\n   * @param asset The address of the underlying asset supplied\n   * @param useAsCollateral True if the user wants to use the supply as collateral, false otherwise\n   */\n  function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;\n\n  /**\n   * @notice Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\n   * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\n   *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n   * @param user The address of the borrower getting liquidated\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n   * @param receiveAToken True if the liquidators wants to receive the collateral aTokens, `false` if he wants\n   * to receive the underlying collateral asset directly\n   */\n  function liquidationCall(\n    address collateralAsset,\n    address debtAsset,\n    address user,\n    uint256 debtToCover,\n    bool receiveAToken\n  ) external;\n\n  /**\n   * @notice Allows smartcontracts to access the liquidity of the pool within one transaction,\n   * as long as the amount taken plus a fee is returned.\n   * @dev IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept\n   * into consideration. For further details please visit https://docs.aave.com/developers/\n   * @param receiverAddress The address of the contract receiving the funds, implementing IFlashLoanReceiver interface\n   * @param assets The addresses of the assets being flash-borrowed\n   * @param amounts The amounts of the assets being flash-borrowed\n   * @param interestRateModes Types of the debt to open if the flash loan is not returned:\n   *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\n   *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n   *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n   * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\n   * @param params Variadic packed params to pass to the receiver as extra information\n   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function flashLoan(\n    address receiverAddress,\n    address[] calldata assets,\n    uint256[] calldata amounts,\n    uint256[] calldata interestRateModes,\n    address onBehalfOf,\n    bytes calldata params,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @notice Allows smartcontracts to access the liquidity of the pool within one transaction,\n   * as long as the amount taken plus a fee is returned.\n   * @dev IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept\n   * into consideration. For further details please visit https://docs.aave.com/developers/\n   * @param receiverAddress The address of the contract receiving the funds, implementing IFlashLoanSimpleReceiver interface\n   * @param asset The address of the asset being flash-borrowed\n   * @param amount The amount of the asset being flash-borrowed\n   * @param params Variadic packed params to pass to the receiver as extra information\n   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function flashLoanSimple(\n    address receiverAddress,\n    address asset,\n    uint256 amount,\n    bytes calldata params,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @notice Returns the user account data across all the reserves\n   * @param user The address of the user\n   * @return totalCollateralBase The total collateral of the user in the base currency used by the price feed\n   * @return totalDebtBase The total debt of the user in the base currency used by the price feed\n   * @return availableBorrowsBase The borrowing power left of the user in the base currency used by the price feed\n   * @return currentLiquidationThreshold The liquidation threshold of the user\n   * @return ltv The loan to value of The user\n   * @return healthFactor The current health factor of the user\n   */\n  function getUserAccountData(\n    address user\n  )\n    external\n    view\n    returns (\n      uint256 totalCollateralBase,\n      uint256 totalDebtBase,\n      uint256 availableBorrowsBase,\n      uint256 currentLiquidationThreshold,\n      uint256 ltv,\n      uint256 healthFactor\n    );\n\n  /**\n   * @notice Initializes a reserve, activating it, assigning an aToken and debt tokens and an\n   * interest rate strategy\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param aTokenAddress The address of the aToken that will be assigned to the reserve\n   * @param stableDebtAddress The address of the StableDebtToken that will be assigned to the reserve\n   * @param variableDebtAddress The address of the VariableDebtToken that will be assigned to the reserve\n   * @param interestRateStrategyAddress The address of the interest rate strategy contract\n   */\n  function initReserve(\n    address asset,\n    address aTokenAddress,\n    address stableDebtAddress,\n    address variableDebtAddress,\n    address interestRateStrategyAddress\n  ) external;\n\n  /**\n   * @notice Drop a reserve\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   */\n  function dropReserve(address asset) external;\n\n  /**\n   * @notice Updates the address of the interest rate strategy contract\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param rateStrategyAddress The address of the interest rate strategy contract\n   */\n  function setReserveInterestRateStrategyAddress(\n    address asset,\n    address rateStrategyAddress\n  ) external;\n\n  /**\n   * @notice Sets the configuration bitmap of the reserve as a whole\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param configuration The new configuration bitmap\n   */\n  function setConfiguration(\n    address asset,\n    DataTypes.ReserveConfigurationMap calldata configuration\n  ) external;\n\n  /**\n   * @notice Returns the configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The configuration of the reserve\n   */\n  function getConfiguration(\n    address asset\n  ) external view returns (DataTypes.ReserveConfigurationMap memory);\n\n  /**\n   * @notice Returns the configuration of the user across all the reserves\n   * @param user The user address\n   * @return The configuration of the user\n   */\n  function getUserConfiguration(\n    address user\n  ) external view returns (DataTypes.UserConfigurationMap memory);\n\n  /**\n   * @notice Returns the normalized income of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve's normalized income\n   */\n  function getReserveNormalizedIncome(address asset) external view returns (uint256);\n\n  /**\n   * @notice Returns the normalized variable debt per unit of asset\n   * @dev WARNING: This function is intended to be used primarily by the protocol itself to get a\n   * \"dynamic\" variable index based on time, current stored index and virtual rate at the current\n   * moment (approx. a borrower would get if opening a position). This means that is always used in\n   * combination with variable debt supply/balances.\n   * If using this function externally, consider that is possible to have an increasing normalized\n   * variable debt that is not equivalent to how the variable debt index would be updated in storage\n   * (e.g. only updates with non-zero variable debt supply)\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve normalized variable debt\n   */\n  function getReserveNormalizedVariableDebt(address asset) external view returns (uint256);\n\n  /**\n   * @notice Returns the state and configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The state and configuration data of the reserve\n   */\n  function getReserveData(address asset) external view returns (DataTypes.ReserveData memory);\n\n  /**\n   * @notice Validates and finalizes an aToken transfer\n   * @dev Only callable by the overlying aToken of the `asset`\n   * @param asset The address of the underlying asset of the aToken\n   * @param from The user from which the aTokens are transferred\n   * @param to The user receiving the aTokens\n   * @param amount The amount being transferred/withdrawn\n   * @param balanceFromBefore The aToken balance of the `from` user before the transfer\n   * @param balanceToBefore The aToken balance of the `to` user before the transfer\n   */\n  function finalizeTransfer(\n    address asset,\n    address from,\n    address to,\n    uint256 amount,\n    uint256 balanceFromBefore,\n    uint256 balanceToBefore\n  ) external;\n\n  /**\n   * @notice Returns the list of the underlying assets of all the initialized reserves\n   * @dev It does not include dropped reserves\n   * @return The addresses of the underlying assets of the initialized reserves\n   */\n  function getReservesList() external view returns (address[] memory);\n\n  /**\n   * @notice Returns the address of the underlying asset of a reserve by the reserve id as stored in the DataTypes.ReserveData struct\n   * @param id The id of the reserve as stored in the DataTypes.ReserveData struct\n   * @return The address of the reserve associated with id\n   */\n  function getReserveAddressById(uint16 id) external view returns (address);\n\n  /**\n   * @notice Returns the PoolAddressesProvider connected to this contract\n   * @return The address of the PoolAddressesProvider\n   */\n  function ADDRESSES_PROVIDER() external view returns (IPoolAddressesProvider);\n\n  /**\n   * @notice Updates the protocol fee on the bridging\n   * @param bridgeProtocolFee The part of the premium sent to the protocol treasury\n   */\n  function updateBridgeProtocolFee(uint256 bridgeProtocolFee) external;\n\n  /**\n   * @notice Updates flash loan premiums. Flash loan premium consists of two parts:\n   * - A part is sent to aToken holders as extra, one time accumulated interest\n   * - A part is collected by the protocol treasury\n   * @dev The total premium is calculated on the total borrowed amount\n   * @dev The premium to protocol is calculated on the total premium, being a percentage of `flashLoanPremiumTotal`\n   * @dev Only callable by the PoolConfigurator contract\n   * @param flashLoanPremiumTotal The total premium, expressed in bps\n   * @param flashLoanPremiumToProtocol The part of the premium sent to the protocol treasury, expressed in bps\n   */\n  function updateFlashloanPremiums(\n    uint128 flashLoanPremiumTotal,\n    uint128 flashLoanPremiumToProtocol\n  ) external;\n\n  /**\n   * @notice Configures a new category for the eMode.\n   * @dev In eMode, the protocol allows very high borrowing power to borrow assets of the same category.\n   * The category 0 is reserved as it's the default for volatile assets\n   * @param id The id of the category\n   * @param config The configuration of the category\n   */\n  function configureEModeCategory(uint8 id, DataTypes.EModeCategory memory config) external;\n\n  /**\n   * @notice Returns the data of an eMode category\n   * @param id The id of the category\n   * @return The configuration data of the category\n   */\n  function getEModeCategoryData(uint8 id) external view returns (DataTypes.EModeCategory memory);\n\n  /**\n   * @notice Allows a user to use the protocol in eMode\n   * @param categoryId The id of the category\n   */\n  function setUserEMode(uint8 categoryId) external;\n\n  /**\n   * @notice Returns the eMode the user is using\n   * @param user The address of the user\n   * @return The eMode id\n   */\n  function getUserEMode(address user) external view returns (uint256);\n\n  /**\n   * @notice Resets the isolation mode total debt of the given asset to zero\n   * @dev It requires the given asset has zero debt ceiling\n   * @param asset The address of the underlying asset to reset the isolationModeTotalDebt\n   */\n  function resetIsolationModeTotalDebt(address asset) external;\n\n  /**\n   * @notice Returns the percentage of available liquidity that can be borrowed at once at stable rate\n   * @return The percentage of available liquidity to borrow, expressed in bps\n   */\n  function MAX_STABLE_RATE_BORROW_SIZE_PERCENT() external view returns (uint256);\n\n  /**\n   * @notice Returns the total fee on flash loans\n   * @return The total fee on flashloans\n   */\n  function FLASHLOAN_PREMIUM_TOTAL() external view returns (uint128);\n\n  /**\n   * @notice Returns the part of the bridge fees sent to protocol\n   * @return The bridge fee sent to the protocol treasury\n   */\n  function BRIDGE_PROTOCOL_FEE() external view returns (uint256);\n\n  /**\n   * @notice Returns the part of the flashloan fees sent to protocol\n   * @return The flashloan fee sent to the protocol treasury\n   */\n  function FLASHLOAN_PREMIUM_TO_PROTOCOL() external view returns (uint128);\n\n  /**\n   * @notice Returns the maximum number of reserves supported to be listed in this Pool\n   * @return The maximum number of reserves supported\n   */\n  function MAX_NUMBER_RESERVES() external view returns (uint16);\n\n  /**\n   * @notice Mints the assets accrued through the reserve factor to the treasury in the form of aTokens\n   * @param assets The list of reserves for which the minting needs to be executed\n   */\n  function mintToTreasury(address[] calldata assets) external;\n\n  /**\n   * @notice Rescue and transfer tokens locked in this contract\n   * @param token The address of the token\n   * @param to The address of the recipient\n   * @param amount The amount of token to transfer\n   */\n  function rescueTokens(address token, address to, uint256 amount) external;\n\n  /**\n   * @notice Supplies an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n   * - E.g. User supplies 100 USDC and gets in return 100 aUSDC\n   * @dev Deprecated: Use the `supply` function instead\n   * @param asset The address of the underlying asset to supply\n   * @param amount The amount to be supplied\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n   *   is a different wallet\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function deposit(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) external;\n}\n"
    },
    "@aave/core-v3/contracts/interfaces/IPoolAddressesProvider.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\n/**\n * @title IPoolAddressesProvider\n * @author Aave\n * @notice Defines the basic interface for a Pool Addresses Provider.\n */\ninterface IPoolAddressesProvider {\n  /**\n   * @dev Emitted when the market identifier is updated.\n   * @param oldMarketId The old id of the market\n   * @param newMarketId The new id of the market\n   */\n  event MarketIdSet(string indexed oldMarketId, string indexed newMarketId);\n\n  /**\n   * @dev Emitted when the pool is updated.\n   * @param oldAddress The old address of the Pool\n   * @param newAddress The new address of the Pool\n   */\n  event PoolUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the pool configurator is updated.\n   * @param oldAddress The old address of the PoolConfigurator\n   * @param newAddress The new address of the PoolConfigurator\n   */\n  event PoolConfiguratorUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the price oracle is updated.\n   * @param oldAddress The old address of the PriceOracle\n   * @param newAddress The new address of the PriceOracle\n   */\n  event PriceOracleUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the ACL manager is updated.\n   * @param oldAddress The old address of the ACLManager\n   * @param newAddress The new address of the ACLManager\n   */\n  event ACLManagerUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the ACL admin is updated.\n   * @param oldAddress The old address of the ACLAdmin\n   * @param newAddress The new address of the ACLAdmin\n   */\n  event ACLAdminUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the price oracle sentinel is updated.\n   * @param oldAddress The old address of the PriceOracleSentinel\n   * @param newAddress The new address of the PriceOracleSentinel\n   */\n  event PriceOracleSentinelUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the pool data provider is updated.\n   * @param oldAddress The old address of the PoolDataProvider\n   * @param newAddress The new address of the PoolDataProvider\n   */\n  event PoolDataProviderUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when a new proxy is created.\n   * @param id The identifier of the proxy\n   * @param proxyAddress The address of the created proxy contract\n   * @param implementationAddress The address of the implementation contract\n   */\n  event ProxyCreated(\n    bytes32 indexed id,\n    address indexed proxyAddress,\n    address indexed implementationAddress\n  );\n\n  /**\n   * @dev Emitted when a new non-proxied contract address is registered.\n   * @param id The identifier of the contract\n   * @param oldAddress The address of the old contract\n   * @param newAddress The address of the new contract\n   */\n  event AddressSet(bytes32 indexed id, address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the implementation of the proxy registered with id is updated\n   * @param id The identifier of the contract\n   * @param proxyAddress The address of the proxy contract\n   * @param oldImplementationAddress The address of the old implementation contract\n   * @param newImplementationAddress The address of the new implementation contract\n   */\n  event AddressSetAsProxy(\n    bytes32 indexed id,\n    address indexed proxyAddress,\n    address oldImplementationAddress,\n    address indexed newImplementationAddress\n  );\n\n  /**\n   * @notice Returns the id of the Aave market to which this contract points to.\n   * @return The market id\n   */\n  function getMarketId() external view returns (string memory);\n\n  /**\n   * @notice Associates an id with a specific PoolAddressesProvider.\n   * @dev This can be used to create an onchain registry of PoolAddressesProviders to\n   * identify and validate multiple Aave markets.\n   * @param newMarketId The market id\n   */\n  function setMarketId(string calldata newMarketId) external;\n\n  /**\n   * @notice Returns an address by its identifier.\n   * @dev The returned address might be an EOA or a contract, potentially proxied\n   * @dev It returns ZERO if there is no registered address with the given id\n   * @param id The id\n   * @return The address of the registered for the specified id\n   */\n  function getAddress(bytes32 id) external view returns (address);\n\n  /**\n   * @notice General function to update the implementation of a proxy registered with\n   * certain `id`. If there is no proxy registered, it will instantiate one and\n   * set as implementation the `newImplementationAddress`.\n   * @dev IMPORTANT Use this function carefully, only for ids that don't have an explicit\n   * setter function, in order to avoid unexpected consequences\n   * @param id The id\n   * @param newImplementationAddress The address of the new implementation\n   */\n  function setAddressAsProxy(bytes32 id, address newImplementationAddress) external;\n\n  /**\n   * @notice Sets an address for an id replacing the address saved in the addresses map.\n   * @dev IMPORTANT Use this function carefully, as it will do a hard replacement\n   * @param id The id\n   * @param newAddress The address to set\n   */\n  function setAddress(bytes32 id, address newAddress) external;\n\n  /**\n   * @notice Returns the address of the Pool proxy.\n   * @return The Pool proxy address\n   */\n  function getPool() external view returns (address);\n\n  /**\n   * @notice Updates the implementation of the Pool, or creates a proxy\n   * setting the new `pool` implementation when the function is called for the first time.\n   * @param newPoolImpl The new Pool implementation\n   */\n  function setPoolImpl(address newPoolImpl) external;\n\n  /**\n   * @notice Returns the address of the PoolConfigurator proxy.\n   * @return The PoolConfigurator proxy address\n   */\n  function getPoolConfigurator() external view returns (address);\n\n  /**\n   * @notice Updates the implementation of the PoolConfigurator, or creates a proxy\n   * setting the new `PoolConfigurator` implementation when the function is called for the first time.\n   * @param newPoolConfiguratorImpl The new PoolConfigurator implementation\n   */\n  function setPoolConfiguratorImpl(address newPoolConfiguratorImpl) external;\n\n  /**\n   * @notice Returns the address of the price oracle.\n   * @return The address of the PriceOracle\n   */\n  function getPriceOracle() external view returns (address);\n\n  /**\n   * @notice Updates the address of the price oracle.\n   * @param newPriceOracle The address of the new PriceOracle\n   */\n  function setPriceOracle(address newPriceOracle) external;\n\n  /**\n   * @notice Returns the address of the ACL manager.\n   * @return The address of the ACLManager\n   */\n  function getACLManager() external view returns (address);\n\n  /**\n   * @notice Updates the address of the ACL manager.\n   * @param newAclManager The address of the new ACLManager\n   */\n  function setACLManager(address newAclManager) external;\n\n  /**\n   * @notice Returns the address of the ACL admin.\n   * @return The address of the ACL admin\n   */\n  function getACLAdmin() external view returns (address);\n\n  /**\n   * @notice Updates the address of the ACL admin.\n   * @param newAclAdmin The address of the new ACL admin\n   */\n  function setACLAdmin(address newAclAdmin) external;\n\n  /**\n   * @notice Returns the address of the price oracle sentinel.\n   * @return The address of the PriceOracleSentinel\n   */\n  function getPriceOracleSentinel() external view returns (address);\n\n  /**\n   * @notice Updates the address of the price oracle sentinel.\n   * @param newPriceOracleSentinel The address of the new PriceOracleSentinel\n   */\n  function setPriceOracleSentinel(address newPriceOracleSentinel) external;\n\n  /**\n   * @notice Returns the address of the data provider.\n   * @return The address of the DataProvider\n   */\n  function getPoolDataProvider() external view returns (address);\n\n  /**\n   * @notice Updates the address of the data provider.\n   * @param newDataProvider The address of the new DataProvider\n   */\n  function setPoolDataProvider(address newDataProvider) external;\n}\n"
    },
    "@aave/core-v3/contracts/protocol/libraries/types/DataTypes.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nlibrary DataTypes {\n  struct ReserveData {\n    //stores the reserve configuration\n    ReserveConfigurationMap configuration;\n    //the liquidity index. Expressed in ray\n    uint128 liquidityIndex;\n    //the current supply rate. Expressed in ray\n    uint128 currentLiquidityRate;\n    //variable borrow index. Expressed in ray\n    uint128 variableBorrowIndex;\n    //the current variable borrow rate. Expressed in ray\n    uint128 currentVariableBorrowRate;\n    //the current stable borrow rate. Expressed in ray\n    uint128 currentStableBorrowRate;\n    //timestamp of last update\n    uint40 lastUpdateTimestamp;\n    //the id of the reserve. Represents the position in the list of the active reserves\n    uint16 id;\n    //aToken address\n    address aTokenAddress;\n    //stableDebtToken address\n    address stableDebtTokenAddress;\n    //variableDebtToken address\n    address variableDebtTokenAddress;\n    //address of the interest rate strategy\n    address interestRateStrategyAddress;\n    //the current treasury balance, scaled\n    uint128 accruedToTreasury;\n    //the outstanding unbacked aTokens minted through the bridging feature\n    uint128 unbacked;\n    //the outstanding debt borrowed against this asset in isolation mode\n    uint128 isolationModeTotalDebt;\n  }\n\n  struct ReserveConfigurationMap {\n    //bit 0-15: LTV\n    //bit 16-31: Liq. threshold\n    //bit 32-47: Liq. bonus\n    //bit 48-55: Decimals\n    //bit 56: reserve is active\n    //bit 57: reserve is frozen\n    //bit 58: borrowing is enabled\n    //bit 59: stable rate borrowing enabled\n    //bit 60: asset is paused\n    //bit 61: borrowing in isolation mode is enabled\n    //bit 62: siloed borrowing enabled\n    //bit 63: flashloaning enabled\n    //bit 64-79: reserve factor\n    //bit 80-115 borrow cap in whole tokens, borrowCap == 0 => no cap\n    //bit 116-151 supply cap in whole tokens, supplyCap == 0 => no cap\n    //bit 152-167 liquidation protocol fee\n    //bit 168-175 eMode category\n    //bit 176-211 unbacked mint cap in whole tokens, unbackedMintCap == 0 => minting disabled\n    //bit 212-251 debt ceiling for isolation mode with (ReserveConfiguration::DEBT_CEILING_DECIMALS) decimals\n    //bit 252-255 unused\n\n    uint256 data;\n  }\n\n  struct UserConfigurationMap {\n    /**\n     * @dev Bitmap of the users collaterals and borrows. It is divided in pairs of bits, one pair per asset.\n     * The first bit indicates if an asset is used as collateral by the user, the second whether an\n     * asset is borrowed by the user.\n     */\n    uint256 data;\n  }\n\n  struct EModeCategory {\n    // each eMode category has a custom ltv and liquidation threshold\n    uint16 ltv;\n    uint16 liquidationThreshold;\n    uint16 liquidationBonus;\n    // each eMode category may or may not have a custom oracle to override the individual assets price oracles\n    address priceSource;\n    string label;\n  }\n\n  enum InterestRateMode {NONE, STABLE, VARIABLE}\n\n  struct ReserveCache {\n    uint256 currScaledVariableDebt;\n    uint256 nextScaledVariableDebt;\n    uint256 currPrincipalStableDebt;\n    uint256 currAvgStableBorrowRate;\n    uint256 currTotalStableDebt;\n    uint256 nextAvgStableBorrowRate;\n    uint256 nextTotalStableDebt;\n    uint256 currLiquidityIndex;\n    uint256 nextLiquidityIndex;\n    uint256 currVariableBorrowIndex;\n    uint256 nextVariableBorrowIndex;\n    uint256 currLiquidityRate;\n    uint256 currVariableBorrowRate;\n    uint256 reserveFactor;\n    ReserveConfigurationMap reserveConfiguration;\n    address aTokenAddress;\n    address stableDebtTokenAddress;\n    address variableDebtTokenAddress;\n    uint40 reserveLastUpdateTimestamp;\n    uint40 stableDebtLastUpdateTimestamp;\n  }\n\n  struct ExecuteLiquidationCallParams {\n    uint256 reservesCount;\n    uint256 debtToCover;\n    address collateralAsset;\n    address debtAsset;\n    address user;\n    bool receiveAToken;\n    address priceOracle;\n    uint8 userEModeCategory;\n    address priceOracleSentinel;\n  }\n\n  struct ExecuteSupplyParams {\n    address asset;\n    uint256 amount;\n    address onBehalfOf;\n    uint16 referralCode;\n  }\n\n  struct ExecuteBorrowParams {\n    address asset;\n    address user;\n    address onBehalfOf;\n    uint256 amount;\n    InterestRateMode interestRateMode;\n    uint16 referralCode;\n    bool releaseUnderlying;\n    uint256 maxStableRateBorrowSizePercent;\n    uint256 reservesCount;\n    address oracle;\n    uint8 userEModeCategory;\n    address priceOracleSentinel;\n  }\n\n  struct ExecuteRepayParams {\n    address asset;\n    uint256 amount;\n    InterestRateMode interestRateMode;\n    address onBehalfOf;\n    bool useATokens;\n  }\n\n  struct ExecuteWithdrawParams {\n    address asset;\n    uint256 amount;\n    address to;\n    uint256 reservesCount;\n    address oracle;\n    uint8 userEModeCategory;\n  }\n\n  struct ExecuteSetUserEModeParams {\n    uint256 reservesCount;\n    address oracle;\n    uint8 categoryId;\n  }\n\n  struct FinalizeTransferParams {\n    address asset;\n    address from;\n    address to;\n    uint256 amount;\n    uint256 balanceFromBefore;\n    uint256 balanceToBefore;\n    uint256 reservesCount;\n    address oracle;\n    uint8 fromEModeCategory;\n  }\n\n  struct FlashloanParams {\n    address receiverAddress;\n    address[] assets;\n    uint256[] amounts;\n    uint256[] interestRateModes;\n    address onBehalfOf;\n    bytes params;\n    uint16 referralCode;\n    uint256 flashLoanPremiumToProtocol;\n    uint256 flashLoanPremiumTotal;\n    uint256 maxStableRateBorrowSizePercent;\n    uint256 reservesCount;\n    address addressesProvider;\n    uint8 userEModeCategory;\n    bool isAuthorizedFlashBorrower;\n  }\n\n  struct FlashloanSimpleParams {\n    address receiverAddress;\n    address asset;\n    uint256 amount;\n    bytes params;\n    uint16 referralCode;\n    uint256 flashLoanPremiumToProtocol;\n    uint256 flashLoanPremiumTotal;\n  }\n\n  struct FlashLoanRepaymentParams {\n    uint256 amount;\n    uint256 totalPremium;\n    uint256 flashLoanPremiumToProtocol;\n    address asset;\n    address receiverAddress;\n    uint16 referralCode;\n  }\n\n  struct CalculateUserAccountDataParams {\n    UserConfigurationMap userConfig;\n    uint256 reservesCount;\n    address user;\n    address oracle;\n    uint8 userEModeCategory;\n  }\n\n  struct ValidateBorrowParams {\n    ReserveCache reserveCache;\n    UserConfigurationMap userConfig;\n    address asset;\n    address userAddress;\n    uint256 amount;\n    InterestRateMode interestRateMode;\n    uint256 maxStableLoanPercent;\n    uint256 reservesCount;\n    address oracle;\n    uint8 userEModeCategory;\n    address priceOracleSentinel;\n    bool isolationModeActive;\n    address isolationModeCollateralAddress;\n    uint256 isolationModeDebtCeiling;\n  }\n\n  struct ValidateLiquidationCallParams {\n    ReserveCache debtReserveCache;\n    uint256 totalDebt;\n    uint256 healthFactor;\n    address priceOracleSentinel;\n  }\n\n  struct CalculateInterestRatesParams {\n    uint256 unbacked;\n    uint256 liquidityAdded;\n    uint256 liquidityTaken;\n    uint256 totalStableDebt;\n    uint256 totalVariableDebt;\n    uint256 averageStableBorrowRate;\n    uint256 reserveFactor;\n    address reserve;\n    address aToken;\n  }\n\n  struct InitReserveParams {\n    address asset;\n    address aTokenAddress;\n    address stableDebtAddress;\n    address variableDebtAddress;\n    address interestRateStrategyAddress;\n    uint16 reservesCount;\n    uint16 maxNumberReserves;\n  }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/applications/CCIPReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IAny2EVMMessageReceiver} from \"../interfaces/IAny2EVMMessageReceiver.sol\";\n\nimport {Client} from \"../libraries/Client.sol\";\n\nimport {IERC165} from \"../../vendor/openzeppelin-solidity/v4.8.0/contracts/utils/introspection/IERC165.sol\";\n\n/// @title CCIPReceiver - Base contract for CCIP applications that can receive messages.\nabstract contract CCIPReceiver is IAny2EVMMessageReceiver, IERC165 {\n  address internal immutable i_router;\n\n  constructor(address router) {\n    if (router == address(0)) revert InvalidRouter(address(0));\n    i_router = router;\n  }\n\n  /// @notice IERC165 supports an interfaceId\n  /// @param interfaceId The interfaceId to check\n  /// @return true if the interfaceId is supported\n  /// @dev Should indicate whether the contract implements IAny2EVMMessageReceiver\n  /// e.g. return interfaceId == type(IAny2EVMMessageReceiver).interfaceId || interfaceId == type(IERC165).interfaceId\n  /// This allows CCIP to check if ccipReceive is available before calling it.\n  /// If this returns false or reverts, only tokens are transferred to the receiver.\n  /// If this returns true, tokens are transferred and ccipReceive is called atomically.\n  /// Additionally, if the receiver address does not have code associated with\n  /// it at the time of execution (EXTCODESIZE returns 0), only tokens will be transferred.\n  function supportsInterface(bytes4 interfaceId) public pure virtual override returns (bool) {\n    return interfaceId == type(IAny2EVMMessageReceiver).interfaceId || interfaceId == type(IERC165).interfaceId;\n  }\n\n  /// @inheritdoc IAny2EVMMessageReceiver\n  function ccipReceive(Client.Any2EVMMessage calldata message) external virtual override onlyRouter {\n    _ccipReceive(message);\n  }\n\n  /// @notice Override this function in your implementation.\n  /// @param message Any2EVMMessage\n  function _ccipReceive(Client.Any2EVMMessage memory message) internal virtual;\n\n  /////////////////////////////////////////////////////////////////////\n  // Plumbing\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Return the current router\n  /// @return i_router address\n  function getRouter() public view returns (address) {\n    return address(i_router);\n  }\n\n  error InvalidRouter(address router);\n\n  /// @dev only calls from the set router are accepted.\n  modifier onlyRouter() {\n    if (msg.sender != address(i_router)) revert InvalidRouter(msg.sender);\n    _;\n  }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IAny2EVMMessageReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Client} from \"../libraries/Client.sol\";\n\n/// @notice Application contracts that intend to receive messages from\n/// the router should implement this interface.\ninterface IAny2EVMMessageReceiver {\n  /// @notice Called by the Router to deliver a message.\n  /// If this reverts, any token transfers also revert. The message\n  /// will move to a FAILED state and become available for manual execution.\n  /// @param message CCIP Message\n  /// @dev Note ensure you check the msg.sender is the OffRampRouter\n  function ccipReceive(Client.Any2EVMMessage calldata message) external;\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Client} from \"../libraries/Client.sol\";\n\ninterface IRouterClient {\n  error UnsupportedDestinationChain(uint64 destChainSelector);\n  error InsufficientFeeTokenAmount();\n  error InvalidMsgValue();\n\n  /// @notice Checks if the given chain ID is supported for sending/receiving.\n  /// @param chainSelector The chain to check.\n  /// @return supported is true if it is supported, false if not.\n  function isChainSupported(uint64 chainSelector) external view returns (bool supported);\n\n  /// @notice Gets a list of all supported tokens which can be sent or received\n  /// to/from a given chain id.\n  /// @param chainSelector The chainSelector.\n  /// @return tokens The addresses of all tokens that are supported.\n  function getSupportedTokens(uint64 chainSelector) external view returns (address[] memory tokens);\n\n  /// @param destinationChainSelector The destination chainSelector\n  /// @param message The cross-chain CCIP message including data and/or tokens\n  /// @return fee returns execution fee for the message\n  /// delivery to destination chain, denominated in the feeToken specified in the message.\n  /// @dev Reverts with appropriate reason upon invalid message.\n  function getFee(\n    uint64 destinationChainSelector,\n    Client.EVM2AnyMessage memory message\n  ) external view returns (uint256 fee);\n\n  /// @notice Request a message to be sent to the destination chain\n  /// @param destinationChainSelector The destination chain ID\n  /// @param message The cross-chain CCIP message including data and/or tokens\n  /// @return messageId The message ID\n  /// @dev Note if msg.value is larger than the required fee (from getFee) we accept\n  /// the overpayment with no refund.\n  /// @dev Reverts with appropriate reason upon invalid message.\n  function ccipSend(\n    uint64 destinationChainSelector,\n    Client.EVM2AnyMessage calldata message\n  ) external payable returns (bytes32);\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// End consumer library.\nlibrary Client {\n  /// @dev RMN depends on this struct, if changing, please notify the RMN maintainers.\n  struct EVMTokenAmount {\n    address token; // token address on the local chain.\n    uint256 amount; // Amount of tokens.\n  }\n\n  struct Any2EVMMessage {\n    bytes32 messageId; // MessageId corresponding to ccipSend on source.\n    uint64 sourceChainSelector; // Source chain selector.\n    bytes sender; // abi.decode(sender) if coming from an EVM chain.\n    bytes data; // payload sent in original message.\n    EVMTokenAmount[] destTokenAmounts; // Tokens and their amounts in their destination chain representation.\n  }\n\n  // If extraArgs is empty bytes, the default is 200k gas limit.\n  struct EVM2AnyMessage {\n    bytes receiver; // abi.encode(receiver address) for dest EVM chains\n    bytes data; // Data payload\n    EVMTokenAmount[] tokenAmounts; // Token transfers\n    address feeToken; // Address of feeToken. address(0) means you will send msg.value.\n    bytes extraArgs; // Populate this with _argsToBytes(EVMExtraArgsV1)\n  }\n\n  // bytes4(keccak256(\"CCIP EVMExtraArgsV1\"));\n  bytes4 public constant EVM_EXTRA_ARGS_V1_TAG = 0x97a657c9;\n  struct EVMExtraArgsV1 {\n    uint256 gasLimit;\n  }\n\n  function _argsToBytes(EVMExtraArgsV1 memory extraArgs) internal pure returns (bytes memory bts) {\n    return abi.encodeWithSelector(EVM_EXTRA_ARGS_V1_TAG, extraArgs);\n  }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v4.8.0/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n  /**\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\n   * another (`to`).\n   *\n   * Note that `value` may be zero.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  /**\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n   * a call to {approve}. `value` is the new allowance.\n   */\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n\n  /**\n   * @dev Returns the amount of tokens in existence.\n   */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @dev Returns the amount of tokens owned by `account`.\n   */\n  function balanceOf(address account) external view returns (uint256);\n\n  /**\n   * @dev Moves `amount` tokens from the caller's account to `to`.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transfer(address to, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Returns the remaining number of tokens that `spender` will be\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\n   * zero by default.\n   *\n   * This value changes when {approve} or {transferFrom} are called.\n   */\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\n   * that someone may use both the old and the new allowance by unfortunate\n   * transaction ordering. One possible solution to mitigate this race\n   * condition is to first reduce the spender's allowance to 0 and set the\n   * desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   * Emits an {Approval} event.\n   */\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Moves `amount` tokens from `from` to `to` using the\n   * allowance mechanism. `amount` is then deducted from the caller's\n   * allowance.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v4.8.0/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.20;\n\nimport {IAccessControl} from \"./IAccessControl.sol\";\nimport {Context} from \"../utils/Context.sol\";\nimport {ERC165} from \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/extensions/AccessControlDefaultAdminRules.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/AccessControlDefaultAdminRules.sol)\n\npragma solidity ^0.8.20;\n\nimport {IAccessControlDefaultAdminRules} from \"./IAccessControlDefaultAdminRules.sol\";\nimport {AccessControl, IAccessControl} from \"../AccessControl.sol\";\nimport {SafeCast} from \"../../utils/math/SafeCast.sol\";\nimport {Math} from \"../../utils/math/Math.sol\";\nimport {IERC5313} from \"../../interfaces/IERC5313.sol\";\n\n/**\n * @dev Extension of {AccessControl} that allows specifying special rules to manage\n * the `DEFAULT_ADMIN_ROLE` holder, which is a sensitive role with special permissions\n * over other roles that may potentially have privileged rights in the system.\n *\n * If a specific role doesn't have an admin role assigned, the holder of the\n * `DEFAULT_ADMIN_ROLE` will have the ability to grant it and revoke it.\n *\n * This contract implements the following risk mitigations on top of {AccessControl}:\n *\n * * Only one account holds the `DEFAULT_ADMIN_ROLE` since deployment until it's potentially renounced.\n * * Enforces a 2-step process to transfer the `DEFAULT_ADMIN_ROLE` to another account.\n * * Enforces a configurable delay between the two steps, with the ability to cancel before the transfer is accepted.\n * * The delay can be changed by scheduling, see {changeDefaultAdminDelay}.\n * * It is not possible to use another role to manage the `DEFAULT_ADMIN_ROLE`.\n *\n * Example usage:\n *\n * ```solidity\n * contract MyToken is AccessControlDefaultAdminRules {\n *   constructor() AccessControlDefaultAdminRules(\n *     3 days,\n *     msg.sender // Explicit initial `DEFAULT_ADMIN_ROLE` holder\n *    ) {}\n * }\n * ```\n */\nabstract contract AccessControlDefaultAdminRules is IAccessControlDefaultAdminRules, IERC5313, AccessControl {\n    // pending admin pair read/written together frequently\n    address private _pendingDefaultAdmin;\n    uint48 private _pendingDefaultAdminSchedule; // 0 == unset\n\n    uint48 private _currentDelay;\n    address private _currentDefaultAdmin;\n\n    // pending delay pair read/written together frequently\n    uint48 private _pendingDelay;\n    uint48 private _pendingDelaySchedule; // 0 == unset\n\n    /**\n     * @dev Sets the initial values for {defaultAdminDelay} and {defaultAdmin} address.\n     */\n    constructor(uint48 initialDelay, address initialDefaultAdmin) {\n        if (initialDefaultAdmin == address(0)) {\n            revert AccessControlInvalidDefaultAdmin(address(0));\n        }\n        _currentDelay = initialDelay;\n        _grantRole(DEFAULT_ADMIN_ROLE, initialDefaultAdmin);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlDefaultAdminRules).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC5313-owner}.\n     */\n    function owner() public view virtual returns (address) {\n        return defaultAdmin();\n    }\n\n    ///\n    /// Override AccessControl role management\n    ///\n\n    /**\n     * @dev See {AccessControl-grantRole}. Reverts for `DEFAULT_ADMIN_ROLE`.\n     */\n    function grantRole(bytes32 role, address account) public virtual override(AccessControl, IAccessControl) {\n        if (role == DEFAULT_ADMIN_ROLE) {\n            revert AccessControlEnforcedDefaultAdminRules();\n        }\n        super.grantRole(role, account);\n    }\n\n    /**\n     * @dev See {AccessControl-revokeRole}. Reverts for `DEFAULT_ADMIN_ROLE`.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override(AccessControl, IAccessControl) {\n        if (role == DEFAULT_ADMIN_ROLE) {\n            revert AccessControlEnforcedDefaultAdminRules();\n        }\n        super.revokeRole(role, account);\n    }\n\n    /**\n     * @dev See {AccessControl-renounceRole}.\n     *\n     * For the `DEFAULT_ADMIN_ROLE`, it only allows renouncing in two steps by first calling\n     * {beginDefaultAdminTransfer} to the `address(0)`, so it's required that the {pendingDefaultAdmin} schedule\n     * has also passed when calling this function.\n     *\n     * After its execution, it will not be possible to call `onlyRole(DEFAULT_ADMIN_ROLE)` functions.\n     *\n     * NOTE: Renouncing `DEFAULT_ADMIN_ROLE` will leave the contract without a {defaultAdmin},\n     * thereby disabling any functionality that is only available for it, and the possibility of reassigning a\n     * non-administrated role.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override(AccessControl, IAccessControl) {\n        if (role == DEFAULT_ADMIN_ROLE && account == defaultAdmin()) {\n            (address newDefaultAdmin, uint48 schedule) = pendingDefaultAdmin();\n            if (newDefaultAdmin != address(0) || !_isScheduleSet(schedule) || !_hasSchedulePassed(schedule)) {\n                revert AccessControlEnforcedDefaultAdminDelay(schedule);\n            }\n            delete _pendingDefaultAdminSchedule;\n        }\n        super.renounceRole(role, account);\n    }\n\n    /**\n     * @dev See {AccessControl-_grantRole}.\n     *\n     * For `DEFAULT_ADMIN_ROLE`, it only allows granting if there isn't already a {defaultAdmin} or if the\n     * role has been previously renounced.\n     *\n     * NOTE: Exposing this function through another mechanism may make the `DEFAULT_ADMIN_ROLE`\n     * assignable again. Make sure to guarantee this is the expected behavior in your implementation.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override returns (bool) {\n        if (role == DEFAULT_ADMIN_ROLE) {\n            if (defaultAdmin() != address(0)) {\n                revert AccessControlEnforcedDefaultAdminRules();\n            }\n            _currentDefaultAdmin = account;\n        }\n        return super._grantRole(role, account);\n    }\n\n    /**\n     * @dev See {AccessControl-_revokeRole}.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override returns (bool) {\n        if (role == DEFAULT_ADMIN_ROLE && account == defaultAdmin()) {\n            delete _currentDefaultAdmin;\n        }\n        return super._revokeRole(role, account);\n    }\n\n    /**\n     * @dev See {AccessControl-_setRoleAdmin}. Reverts for `DEFAULT_ADMIN_ROLE`.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual override {\n        if (role == DEFAULT_ADMIN_ROLE) {\n            revert AccessControlEnforcedDefaultAdminRules();\n        }\n        super._setRoleAdmin(role, adminRole);\n    }\n\n    ///\n    /// AccessControlDefaultAdminRules accessors\n    ///\n\n    /**\n     * @inheritdoc IAccessControlDefaultAdminRules\n     */\n    function defaultAdmin() public view virtual returns (address) {\n        return _currentDefaultAdmin;\n    }\n\n    /**\n     * @inheritdoc IAccessControlDefaultAdminRules\n     */\n    function pendingDefaultAdmin() public view virtual returns (address newAdmin, uint48 schedule) {\n        return (_pendingDefaultAdmin, _pendingDefaultAdminSchedule);\n    }\n\n    /**\n     * @inheritdoc IAccessControlDefaultAdminRules\n     */\n    function defaultAdminDelay() public view virtual returns (uint48) {\n        uint48 schedule = _pendingDelaySchedule;\n        return (_isScheduleSet(schedule) && _hasSchedulePassed(schedule)) ? _pendingDelay : _currentDelay;\n    }\n\n    /**\n     * @inheritdoc IAccessControlDefaultAdminRules\n     */\n    function pendingDefaultAdminDelay() public view virtual returns (uint48 newDelay, uint48 schedule) {\n        schedule = _pendingDelaySchedule;\n        return (_isScheduleSet(schedule) && !_hasSchedulePassed(schedule)) ? (_pendingDelay, schedule) : (0, 0);\n    }\n\n    /**\n     * @inheritdoc IAccessControlDefaultAdminRules\n     */\n    function defaultAdminDelayIncreaseWait() public view virtual returns (uint48) {\n        return 5 days;\n    }\n\n    ///\n    /// AccessControlDefaultAdminRules public and internal setters for defaultAdmin/pendingDefaultAdmin\n    ///\n\n    /**\n     * @inheritdoc IAccessControlDefaultAdminRules\n     */\n    function beginDefaultAdminTransfer(address newAdmin) public virtual onlyRole(DEFAULT_ADMIN_ROLE) {\n        _beginDefaultAdminTransfer(newAdmin);\n    }\n\n    /**\n     * @dev See {beginDefaultAdminTransfer}.\n     *\n     * Internal function without access restriction.\n     */\n    function _beginDefaultAdminTransfer(address newAdmin) internal virtual {\n        uint48 newSchedule = SafeCast.toUint48(block.timestamp) + defaultAdminDelay();\n        _setPendingDefaultAdmin(newAdmin, newSchedule);\n        emit DefaultAdminTransferScheduled(newAdmin, newSchedule);\n    }\n\n    /**\n     * @inheritdoc IAccessControlDefaultAdminRules\n     */\n    function cancelDefaultAdminTransfer() public virtual onlyRole(DEFAULT_ADMIN_ROLE) {\n        _cancelDefaultAdminTransfer();\n    }\n\n    /**\n     * @dev See {cancelDefaultAdminTransfer}.\n     *\n     * Internal function without access restriction.\n     */\n    function _cancelDefaultAdminTransfer() internal virtual {\n        _setPendingDefaultAdmin(address(0), 0);\n    }\n\n    /**\n     * @inheritdoc IAccessControlDefaultAdminRules\n     */\n    function acceptDefaultAdminTransfer() public virtual {\n        (address newDefaultAdmin, ) = pendingDefaultAdmin();\n        if (_msgSender() != newDefaultAdmin) {\n            // Enforce newDefaultAdmin explicit acceptance.\n            revert AccessControlInvalidDefaultAdmin(_msgSender());\n        }\n        _acceptDefaultAdminTransfer();\n    }\n\n    /**\n     * @dev See {acceptDefaultAdminTransfer}.\n     *\n     * Internal function without access restriction.\n     */\n    function _acceptDefaultAdminTransfer() internal virtual {\n        (address newAdmin, uint48 schedule) = pendingDefaultAdmin();\n        if (!_isScheduleSet(schedule) || !_hasSchedulePassed(schedule)) {\n            revert AccessControlEnforcedDefaultAdminDelay(schedule);\n        }\n        _revokeRole(DEFAULT_ADMIN_ROLE, defaultAdmin());\n        _grantRole(DEFAULT_ADMIN_ROLE, newAdmin);\n        delete _pendingDefaultAdmin;\n        delete _pendingDefaultAdminSchedule;\n    }\n\n    ///\n    /// AccessControlDefaultAdminRules public and internal setters for defaultAdminDelay/pendingDefaultAdminDelay\n    ///\n\n    /**\n     * @inheritdoc IAccessControlDefaultAdminRules\n     */\n    function changeDefaultAdminDelay(uint48 newDelay) public virtual onlyRole(DEFAULT_ADMIN_ROLE) {\n        _changeDefaultAdminDelay(newDelay);\n    }\n\n    /**\n     * @dev See {changeDefaultAdminDelay}.\n     *\n     * Internal function without access restriction.\n     */\n    function _changeDefaultAdminDelay(uint48 newDelay) internal virtual {\n        uint48 newSchedule = SafeCast.toUint48(block.timestamp) + _delayChangeWait(newDelay);\n        _setPendingDelay(newDelay, newSchedule);\n        emit DefaultAdminDelayChangeScheduled(newDelay, newSchedule);\n    }\n\n    /**\n     * @inheritdoc IAccessControlDefaultAdminRules\n     */\n    function rollbackDefaultAdminDelay() public virtual onlyRole(DEFAULT_ADMIN_ROLE) {\n        _rollbackDefaultAdminDelay();\n    }\n\n    /**\n     * @dev See {rollbackDefaultAdminDelay}.\n     *\n     * Internal function without access restriction.\n     */\n    function _rollbackDefaultAdminDelay() internal virtual {\n        _setPendingDelay(0, 0);\n    }\n\n    /**\n     * @dev Returns the amount of seconds to wait after the `newDelay` will\n     * become the new {defaultAdminDelay}.\n     *\n     * The value returned guarantees that if the delay is reduced, it will go into effect\n     * after a wait that honors the previously set delay.\n     *\n     * See {defaultAdminDelayIncreaseWait}.\n     */\n    function _delayChangeWait(uint48 newDelay) internal view virtual returns (uint48) {\n        uint48 currentDelay = defaultAdminDelay();\n\n        // When increasing the delay, we schedule the delay change to occur after a period of \"new delay\" has passed, up\n        // to a maximum given by defaultAdminDelayIncreaseWait, by default 5 days. For example, if increasing from 1 day\n        // to 3 days, the new delay will come into effect after 3 days. If increasing from 1 day to 10 days, the new\n        // delay will come into effect after 5 days. The 5 day wait period is intended to be able to fix an error like\n        // using milliseconds instead of seconds.\n        //\n        // When decreasing the delay, we wait the difference between \"current delay\" and \"new delay\". This guarantees\n        // that an admin transfer cannot be made faster than \"current delay\" at the time the delay change is scheduled.\n        // For example, if decreasing from 10 days to 3 days, the new delay will come into effect after 7 days.\n        return\n            newDelay > currentDelay\n                ? uint48(Math.min(newDelay, defaultAdminDelayIncreaseWait())) // no need to safecast, both inputs are uint48\n                : currentDelay - newDelay;\n    }\n\n    ///\n    /// Private setters\n    ///\n\n    /**\n     * @dev Setter of the tuple for pending admin and its schedule.\n     *\n     * May emit a DefaultAdminTransferCanceled event.\n     */\n    function _setPendingDefaultAdmin(address newAdmin, uint48 newSchedule) private {\n        (, uint48 oldSchedule) = pendingDefaultAdmin();\n\n        _pendingDefaultAdmin = newAdmin;\n        _pendingDefaultAdminSchedule = newSchedule;\n\n        // An `oldSchedule` from `pendingDefaultAdmin()` is only set if it hasn't been accepted.\n        if (_isScheduleSet(oldSchedule)) {\n            // Emit for implicit cancellations when another default admin was scheduled.\n            emit DefaultAdminTransferCanceled();\n        }\n    }\n\n    /**\n     * @dev Setter of the tuple for pending delay and its schedule.\n     *\n     * May emit a DefaultAdminDelayChangeCanceled event.\n     */\n    function _setPendingDelay(uint48 newDelay, uint48 newSchedule) private {\n        uint48 oldSchedule = _pendingDelaySchedule;\n\n        if (_isScheduleSet(oldSchedule)) {\n            if (_hasSchedulePassed(oldSchedule)) {\n                // Materialize a virtual delay\n                _currentDelay = _pendingDelay;\n            } else {\n                // Emit for implicit cancellations when another delay was scheduled.\n                emit DefaultAdminDelayChangeCanceled();\n            }\n        }\n\n        _pendingDelay = newDelay;\n        _pendingDelaySchedule = newSchedule;\n    }\n\n    ///\n    /// Private helpers\n    ///\n\n    /**\n     * @dev Defines if an `schedule` is considered set. For consistency purposes.\n     */\n    function _isScheduleSet(uint48 schedule) private pure returns (bool) {\n        return schedule != 0;\n    }\n\n    /**\n     * @dev Defines if an `schedule` is considered passed. For consistency purposes.\n     */\n    function _hasSchedulePassed(uint48 schedule) private view returns (bool) {\n        return schedule < block.timestamp;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/extensions/IAccessControlDefaultAdminRules.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/extensions/IAccessControlDefaultAdminRules.sol)\n\npragma solidity ^0.8.20;\n\nimport {IAccessControl} from \"../IAccessControl.sol\";\n\n/**\n * @dev External interface of AccessControlDefaultAdminRules declared to support ERC165 detection.\n */\ninterface IAccessControlDefaultAdminRules is IAccessControl {\n    /**\n     * @dev The new default admin is not a valid default admin.\n     */\n    error AccessControlInvalidDefaultAdmin(address defaultAdmin);\n\n    /**\n     * @dev At least one of the following rules was violated:\n     *\n     * - The `DEFAULT_ADMIN_ROLE` must only be managed by itself.\n     * - The `DEFAULT_ADMIN_ROLE` must only be held by one account at the time.\n     * - Any `DEFAULT_ADMIN_ROLE` transfer must be in two delayed steps.\n     */\n    error AccessControlEnforcedDefaultAdminRules();\n\n    /**\n     * @dev The delay for transferring the default admin delay is enforced and\n     * the operation must wait until `schedule`.\n     *\n     * NOTE: `schedule` can be 0 indicating there's no transfer scheduled.\n     */\n    error AccessControlEnforcedDefaultAdminDelay(uint48 schedule);\n\n    /**\n     * @dev Emitted when a {defaultAdmin} transfer is started, setting `newAdmin` as the next\n     * address to become the {defaultAdmin} by calling {acceptDefaultAdminTransfer} only after `acceptSchedule`\n     * passes.\n     */\n    event DefaultAdminTransferScheduled(address indexed newAdmin, uint48 acceptSchedule);\n\n    /**\n     * @dev Emitted when a {pendingDefaultAdmin} is reset if it was never accepted, regardless of its schedule.\n     */\n    event DefaultAdminTransferCanceled();\n\n    /**\n     * @dev Emitted when a {defaultAdminDelay} change is started, setting `newDelay` as the next\n     * delay to be applied between default admin transfer after `effectSchedule` has passed.\n     */\n    event DefaultAdminDelayChangeScheduled(uint48 newDelay, uint48 effectSchedule);\n\n    /**\n     * @dev Emitted when a {pendingDefaultAdminDelay} is reset if its schedule didn't pass.\n     */\n    event DefaultAdminDelayChangeCanceled();\n\n    /**\n     * @dev Returns the address of the current `DEFAULT_ADMIN_ROLE` holder.\n     */\n    function defaultAdmin() external view returns (address);\n\n    /**\n     * @dev Returns a tuple of a `newAdmin` and an accept schedule.\n     *\n     * After the `schedule` passes, the `newAdmin` will be able to accept the {defaultAdmin} role\n     * by calling {acceptDefaultAdminTransfer}, completing the role transfer.\n     *\n     * A zero value only in `acceptSchedule` indicates no pending admin transfer.\n     *\n     * NOTE: A zero address `newAdmin` means that {defaultAdmin} is being renounced.\n     */\n    function pendingDefaultAdmin() external view returns (address newAdmin, uint48 acceptSchedule);\n\n    /**\n     * @dev Returns the delay required to schedule the acceptance of a {defaultAdmin} transfer started.\n     *\n     * This delay will be added to the current timestamp when calling {beginDefaultAdminTransfer} to set\n     * the acceptance schedule.\n     *\n     * NOTE: If a delay change has been scheduled, it will take effect as soon as the schedule passes, making this\n     * function returns the new delay. See {changeDefaultAdminDelay}.\n     */\n    function defaultAdminDelay() external view returns (uint48);\n\n    /**\n     * @dev Returns a tuple of `newDelay` and an effect schedule.\n     *\n     * After the `schedule` passes, the `newDelay` will get into effect immediately for every\n     * new {defaultAdmin} transfer started with {beginDefaultAdminTransfer}.\n     *\n     * A zero value only in `effectSchedule` indicates no pending delay change.\n     *\n     * NOTE: A zero value only for `newDelay` means that the next {defaultAdminDelay}\n     * will be zero after the effect schedule.\n     */\n    function pendingDefaultAdminDelay() external view returns (uint48 newDelay, uint48 effectSchedule);\n\n    /**\n     * @dev Starts a {defaultAdmin} transfer by setting a {pendingDefaultAdmin} scheduled for acceptance\n     * after the current timestamp plus a {defaultAdminDelay}.\n     *\n     * Requirements:\n     *\n     * - Only can be called by the current {defaultAdmin}.\n     *\n     * Emits a DefaultAdminRoleChangeStarted event.\n     */\n    function beginDefaultAdminTransfer(address newAdmin) external;\n\n    /**\n     * @dev Cancels a {defaultAdmin} transfer previously started with {beginDefaultAdminTransfer}.\n     *\n     * A {pendingDefaultAdmin} not yet accepted can also be cancelled with this function.\n     *\n     * Requirements:\n     *\n     * - Only can be called by the current {defaultAdmin}.\n     *\n     * May emit a DefaultAdminTransferCanceled event.\n     */\n    function cancelDefaultAdminTransfer() external;\n\n    /**\n     * @dev Completes a {defaultAdmin} transfer previously started with {beginDefaultAdminTransfer}.\n     *\n     * After calling the function:\n     *\n     * - `DEFAULT_ADMIN_ROLE` should be granted to the caller.\n     * - `DEFAULT_ADMIN_ROLE` should be revoked from the previous holder.\n     * - {pendingDefaultAdmin} should be reset to zero values.\n     *\n     * Requirements:\n     *\n     * - Only can be called by the {pendingDefaultAdmin}'s `newAdmin`.\n     * - The {pendingDefaultAdmin}'s `acceptSchedule` should've passed.\n     */\n    function acceptDefaultAdminTransfer() external;\n\n    /**\n     * @dev Initiates a {defaultAdminDelay} update by setting a {pendingDefaultAdminDelay} scheduled for getting\n     * into effect after the current timestamp plus a {defaultAdminDelay}.\n     *\n     * This function guarantees that any call to {beginDefaultAdminTransfer} done between the timestamp this\n     * method is called and the {pendingDefaultAdminDelay} effect schedule will use the current {defaultAdminDelay}\n     * set before calling.\n     *\n     * The {pendingDefaultAdminDelay}'s effect schedule is defined in a way that waiting until the schedule and then\n     * calling {beginDefaultAdminTransfer} with the new delay will take at least the same as another {defaultAdmin}\n     * complete transfer (including acceptance).\n     *\n     * The schedule is designed for two scenarios:\n     *\n     * - When the delay is changed for a larger one the schedule is `block.timestamp + newDelay` capped by\n     * {defaultAdminDelayIncreaseWait}.\n     * - When the delay is changed for a shorter one, the schedule is `block.timestamp + (current delay - new delay)`.\n     *\n     * A {pendingDefaultAdminDelay} that never got into effect will be canceled in favor of a new scheduled change.\n     *\n     * Requirements:\n     *\n     * - Only can be called by the current {defaultAdmin}.\n     *\n     * Emits a DefaultAdminDelayChangeScheduled event and may emit a DefaultAdminDelayChangeCanceled event.\n     */\n    function changeDefaultAdminDelay(uint48 newDelay) external;\n\n    /**\n     * @dev Cancels a scheduled {defaultAdminDelay} change.\n     *\n     * Requirements:\n     *\n     * - Only can be called by the current {defaultAdmin}.\n     *\n     * May emit a DefaultAdminDelayChangeCanceled event.\n     */\n    function rollbackDefaultAdminDelay() external;\n\n    /**\n     * @dev Maximum time in seconds for an increase to {defaultAdminDelay} (that is scheduled using {changeDefaultAdminDelay})\n     * to take effect. Default to 5 days.\n     *\n     * When the {defaultAdminDelay} is scheduled to be increased, it goes into effect after the new delay has passed with\n     * the purpose of giving enough time for reverting any accidental change (i.e. using milliseconds instead of seconds)\n     * that may lock the contract. However, to avoid excessive schedules, the wait is capped by this function and it can\n     * be overrode for a custom {defaultAdminDelay} increase scheduling.\n     *\n     * IMPORTANT: Make sure to add a reasonable amount of time while overriding this value, otherwise,\n     * there's a risk of setting a high new delay that goes into effect almost immediately without the\n     * possibility of human intervention in the case of an input error (eg. set milliseconds instead of seconds).\n     */\n    function defaultAdminDelayIncreaseWait() external view returns (uint48);\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC5313.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC5313.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface for the Light Contract Ownership Standard.\n *\n * A standardized minimal interface required to identify an account that controls a contract\n */\ninterface IERC5313 {\n    /**\n     * @dev Gets the address of the owner.\n     */\n    function owner() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC20Permit} from \"../extensions/IERC20Permit.sol\";\nimport {Address} from \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\n     *   {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be\n     * reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value > type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value > type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value > type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value > type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value > type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value > type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value > type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value > type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value > type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value > type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value > type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value > type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value > type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value > type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value > type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value > type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value > type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value > type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value > type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value > type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value > type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value > type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value > type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value > type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value > type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value > type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value > type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value > type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value > type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value > type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value > type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value < 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value > uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value => uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "contracts/Sepolia/interfaces/IAccessManagerSepolia.sol": {
      "content": "// File: contracts/Sepolia/interfaces/IAccessManagerSepolia.sol\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { IAccessControlDefaultAdminRules } from \"@openzeppelin/contracts/access/extensions/IAccessControlDefaultAdminRules.sol\";\n\n/**\n * @title IAccessManagerSepolia Contract Interface\n * @author GhoSafe Protocol\n * @notice Interface for the AccessManagerSepolia contract\n * @dev This interface should be implemented by the AccessManagerSepolia contract.\n */\ninterface IAccessManagerSepolia is IAccessControlDefaultAdminRules {\n\t/**\n\t * @notice Grant owner role to a new address\n\t * @param _newOwner Address of the new owner\n\t */\n\tfunction grantOwnerRole(address _newOwner) external;\n\n\t/**\n\t * @notice Revoke owner role from an address\n\t * @param _oldOwner Address of the old owner\n\t */\n\tfunction revokeOwnerRole(address _oldOwner) external;\n\n\t/**\n\t * @notice Returns the owner role\n\t * @return Owner role\n\t */\n\tfunction OWNER_ROLE() external view returns (bytes32);\n}\n"
    },
    "contracts/Sepolia/interfaces/IGhoSafeIDSepolia.sol": {
      "content": "// File: contracts/Sepolia/interfaces/IGhoSafeIDSepolia.sol\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\n/**\n * @title IGhoSafeIDSepolia Interface\n * @author GhoSafe Protocol\n * @notice Interface for the GhoSafeIDSepolia contract.\n * @dev This interface should be implemented by the GhoSafeIDSepolia contract.\n */\ninterface IGhoSafeIDSepolia {\n\t/**\n\t * @notice Struct for storing detailed credit score data.\n\t * @param loansCount The number of loans taken out by the token owner.\n\t * @param totalAmountBorrowed The total amount borrowed by the token owner.\n\t * @param totalAmountRepaid The total amount repaid by the token owner.\n\t * @param creditScore The credit score of the token owner.\n\t **/\n\tstruct CreditScoreData {\n\t\tuint256 loansCount;\n\t\tuint256 totalAmountBorrowed;\n\t\tuint256 totalAmountRepaid;\n\t\tuint256 creditScore;\n\t}\n\n\t/// @notice Not authorized Caller error\n\terror UnauthorizedAccess(address caller);\n\t/// @notice Token ID does not exist error\n\terror TokenDoesNotExist(uint256 tokenId);\n\t/// @notice GhoSafe ID already minted to an address error\n\terror GhoSafeIdAlreadyMinted(address owner);\n\t/// @notice Transfer not allowed error\n\terror TransferNotAllowed();\n\t/// @notice Invalid arguments length error\n\terror InvalidArgumentsLength(uint256 expected, uint256 actual);\n\n\t/**\n\t * @notice Event emitted when a new GhoSafe ID is minted.\n\t * @param tokenId The ID of the GhoSafe ID.\n\t * @param owner The address of the GhoSafe ID owner.\n\t * @param creditScore The credit score of the GhoSafe ID.\n\t **/\n\tevent GhoSafeIdMinted(\n\t\tuint256 indexed tokenId,\n\t\taddress indexed owner,\n\t\tuint256 creditScore\n\t);\n\n\t/**\n\t * @notice Event emitted when a GhoSafe ID's credit score is updated.\n\t * @param tokenId The ID of the GhoSafe ID.\n\t * @param creditScore The credit score of the GhoSafe ID.\n\t **/\n\tevent CreditScoreUpdated(uint256 indexed tokenId, uint256 creditScore);\n\n\t/**\n\t * @notice Retrieves the credit score data of a specific token.\n\t * @param _tokenId The token ID.\n\t * @return creditScoreData The credit score data.\n\t */\n\tfunction creditScoreDataOf(\n\t\tuint256 _tokenId\n\t) external view returns (CreditScoreData memory creditScoreData);\n\n\t/**\n\t * @notice Retrieves the GhoSafe ID of a specific address.\n\t * @param _owner The address.\n\t * @return tokenId The GhoSafe ID.\n\t */\n\tfunction ghoSafeIdOf(\n\t\taddress _owner\n\t) external view returns (uint256 tokenId);\n\n\t/**\n\t * @notice Retrieves the balance of a specific address.\n\t * @param _owner The address.\n\t * @return balance The balance.\n\t */\n\tfunction balanceOf(address _owner) external view returns (uint256 balance);\n\n\t/**\n\t * @notice Retrieves the owner of a specific token.\n\t * @param _tokenId The token ID.\n\t * @return owner The owner.\n\t */\n\tfunction ownerOf(uint256 _tokenId) external view returns (address owner);\n\n\t/**\n\t * @notice Checks if the contract implements a specific interface.\n\t * @param _interfaceId The interface identifier.\n\t * @return isSupported True if the contract implements the interface.\n\t */\n\tfunction supportsInterface(\n\t\tbytes4 _interfaceId\n\t) external view returns (bool isSupported);\n\n\t/**\n\t * @notice Returns the URI of the token metadata.\n\t * @param _tokenId The token ID.\n\t * @return tokenURI The token URI.\n\t */\n\tfunction tokenURI(uint256 _tokenId) external view returns (string memory);\n\n\t/**\n\t * @notice Mints a new GhoSafe ID token.\n\t * @param _to The address to mint the token to.\n\t * @param _initialCreditScore The initial credit score.\n\t * @param _tokenURI The token URI.\n\t */\n\tfunction safeMint(\n\t\taddress _to,\n\t\tuint256 _initialCreditScore,\n\t\tbytes calldata _tokenURI\n\t) external;\n\n\t/**\n\t * @notice Updates the credit score of a specific token.\n\t * @param _tokenId The token ID.\n\t * @param _newCreditScore The new credit score.\n\t * @param _loansCountIncrement The loans count increment.\n\t * @param _totalAmountBorrowedIncrement The total amount borrowed increment.\n\t * @param _totalAmountRepaidIncrement The total amount repaid increment.\n\t */\n\tfunction updateCreditScore(\n\t\tuint256 _tokenId,\n\t\tuint256 _newCreditScore,\n\t\tuint256 _loansCountIncrement,\n\t\tuint256 _totalAmountBorrowedIncrement,\n\t\tuint256 _totalAmountRepaidIncrement\n\t) external;\n\n\t/**\n\t * @notice Mints a new GhoSafe ID token to the specified address.\n\t * @param _to The address to mint the token to.\n\t * @param _initialCreditScore The initial credit score of the token.\n\t * @param _tokenURI The token URI of the token.\n\t * @dev Only callable by addresses with the MINTER_ROLE.\n\t */\n\tfunction batchSafeMin(\n\t\taddress[] calldata _to,\n\t\tuint256[] calldata _initialCreditScore,\n\t\tbytes[] calldata _tokenURI\n\t) external;\n}\n"
    },
    "contracts/Sepolia/interfaces/IGhoSafeLoanAdvertisementBookSepolia.sol": {
      "content": "// File: contracts/Sepolia/interfaces/IGhoSafeLoanAdvertisementBookSepolia.sol\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\n/**\n * @title GhoSafeLoanAdvertisementBookSepolia Interface\n * @author GhoSafe Protocol\n * @notice Interface for the GhoSafeLoanAdvertisementBookSepolia contract.\n * @dev This interface should be implemented by the GhoSafeLoanAdvertisementBookSepolia contract.\n */\ninterface IGhoSafeLoanAdvertisementBookSepolia {\n\t/**\n\t * @notice Struct for storing loan advertisement data.\n\t * @param timestampLastUpdate The timestamp of the last update.\n\t * @param maxLoanAmount The maximum loan amount (in Gho tokens)\n\t * @param maxDuration The maximum loan duration (in seconds)\n\t * @param interestRate The interest rate (in basis points)\n\t * @param safeAddress The address of the GhoSafe contract.\n\t * @param loanManagerAddress The address of the loan manager contract.\n\t * @param isAvailable The availability of the loan advertisement.\n\t **/\n\tstruct LoanAdvertisement {\n\t\tuint256 timestampLastUpdate;\n\t\tuint256 maxLoanAmount;\n\t\tuint256 maxDuration;\n\t\tuint256 interestRate;\n\t\taddress safeAddress;\n\t\taddress loanManagerAddress;\n\t\tbool isAvailable;\n\t}\n\n\t/// @notice Not authorized Caller error\n\terror UnauthorizedAccess(address caller);\n\n\t/**\n\t * @notice Event emitted when a new loan advertisement is published.\n\t * @param loanId The ID of the loan advertisement.\n\t * @param maxLoanAmount The maximum loan amount (in Gho tokens)\n\t * @param maxDuration The maximum loan duration (in seconds)\n\t * @param interestRate The interest rate (in basis points)\n\t * @param safeAddress The address of the GhoSafe contract.\n\t * @param loanManagerAddress The address of the loan manager contract.\n\t **/\n\tevent LoanAdvertisementPublished(\n\t\tuint256 indexed loanId,\n\t\tuint256 maxLoanAmount,\n\t\tuint256 maxDuration,\n\t\tuint256 interestRate,\n\t\taddress safeAddress,\n\t\taddress loanManagerAddress\n\t);\n\n\t/**\n\t * @notice Event emitted when a loan advertisement is updated.\n\t * @param loanId The ID of the loan advertisement.\n\t * @param maxLoanAmount The maximum loan amount (in Gho tokens)\n\t * @param maxDuration The maximum loan duration (in seconds)\n\t * @param interestRate The interest rate (in basis points)\n\t * @param isAvailable The availability of the loan advertisement.\n\t **/\n\tevent LoanAdvertisementUpdated(\n\t\tuint256 indexed loanId,\n\t\tuint256 maxLoanAmount,\n\t\tuint256 maxDuration,\n\t\tuint256 interestRate,\n\t\tbool isAvailable\n\t);\n\n\t/**\n\t * @notice Publishes a new loan advertisement.\n\t * @param _maxLoanAmount The maximum loan amount in Gho tokens.\n\t * @param _maxDuration The maximum loan duration in seconds.\n\t * @param _interestRate The interest rate in basis points.\n\t * @param _safeAddress The address of the GhoSafe contract.\n\t * @param _loanManagerAddress The address of the loan manager contract.\n\t * @return loanId The ID of the published loan advertisement.\n\t */\n\tfunction publishLoanAdvertisement(\n\t\tuint256 _maxLoanAmount,\n\t\tuint256 _maxDuration,\n\t\tuint256 _interestRate,\n\t\taddress _safeAddress,\n\t\taddress _loanManagerAddress\n\t) external returns (uint256 loanId);\n\n\t/**\n\t * @notice Updates the data of an existing loan advertisement.\n\t * @param _loanId The ID of the loan advertisement.\n\t * @param _maxLoanAmount The updated maximum loan amount.\n\t * @param _maxDuration The updated maximum loan duration.\n\t * @param _interestRate The updated interest rate.\n\t * @param _isAvailable The updated availability status.\n\t */\n\tfunction updateLoanAdvertisementData(\n\t\tuint256 _loanId,\n\t\tuint256 _maxLoanAmount,\n\t\tuint256 _maxDuration,\n\t\tuint256 _interestRate,\n\t\tbool _isAvailable\n\t) external;\n\n\t/**\n\t * @notice Retrieves the data of a specific loan advertisement.\n\t * @param _loanId The ID of the loan advertisement.\n\t * @return loanAdvertisementData The data of the requested loan advertisement.\n\t */\n\tfunction getLoanAdvertisementData(\n\t\tuint256 _loanId\n\t) external view returns (LoanAdvertisement memory loanAdvertisementData);\n}\n"
    },
    "contracts/Sepolia/interfaces/ILoanManagerSepolia.sol": {
      "content": "// File: contracts/Sepolia/interfaces/ILoanManagerSepolia.sol\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { IGhoSafeLoanAdvertisementBookSepolia } from \"../interfaces/IGhoSafeLoanAdvertisementBookSepolia.sol\";\n\n/**\n * @title ILoanManagerSepolia Contract Interface\n * @author GhoSafe Protocol\n * @notice Interface for the LoanManagerSepolia contract\n * @dev This interface should be implemented by the LoanManagerSepolia contract.\n */\ninterface ILoanManagerSepolia {\n\t/**\n\t * @notice Loan struct\n\t * @param loanId ID of the loan.\n\t * @param loanRequestId ID of the loan request.\n\t * @param startTimestamp Timestamp when the loan was started.\n\t * @param duration Duration of the loan in seconds.\n\t * @param interestRate Interest rate for the loan in basis points (BPS).\n\t * @param loanAmount Amount of loan.\n\t * @param collateralAmountOrId Amount or ID of the collateral asset.\n\t * @param collateralChainId Chain ID of the collateral asset.\n\t * @param collateralAddress Address of the collateral asset.\n\t * @param collateralType Type of collateral (ERC20 or ERC721).\n\t * @param borrower Address of the borrower.\n\t */\n\tstruct Loan {\n\t\tuint256 loanId;\n\t\tuint256 loanRequestId;\n\t\tuint256 startTimestamp;\n\t\tuint256 duration;\n\t\tuint256 interestRate;\n\t\tuint256 loanAmount;\n\t\tuint256 collateralAmountOrId;\n\t\tuint64 collateralChainId;\n\t\taddress collateralAddress;\n\t\tbool collateralType;\n\t\taddress borrower;\n\t\tbool isActive;\n\t}\n\n\t/**\n\t * @notice Emitted when loan parameters are updated.\n\t * @param maxLoanDuration The maximum duration of a loan in seconds.\n\t * @param availableBorrowPowerPercent Percentage of total borrow power that is available for borrowing.\n\t * @param maxLoanAmountPercentPerBorrower Maximum loan amount per borrower as a percentage of available borrow power.\n\t */\n\tevent LoanParametersUpdated(\n\t\tuint256 maxLoanDuration,\n\t\tuint256 availableBorrowPowerPercent,\n\t\tuint256 maxLoanAmountPercentPerBorrower\n\t);\n\n\t/**\n\t * @notice Emitted when a loan advertisement is published.\n\t * @param loanAdvertisementId ID of the loan advertisement.\n\t * @param maxLoanDuration The maximum duration of a loan in seconds.\n\t * @param maxLoanAmount Maximum loan amount.\n\t * @param interestRate Interest rate for the loan in basis points (BPS).\n\t */\n\tevent LoanAdvertisementPublished(\n\t\tuint256 loanAdvertisementId,\n\t\tuint256 maxLoanDuration,\n\t\tuint256 maxLoanAmount,\n\t\tuint256 interestRate\n\t);\n\n\t/**\n\t * @notice Emitted when a loan advertisement is updated.\n\t * @param loanAdvertisementId ID of the loan advertisement.\n\t * @param isAvailable Whether the loan advertisement is available.\n\t * @param maxLoanDuration The maximum duration of a loan in seconds.\n\t * @param maxLoanAmount Maximum loan amount.\n\t * @param interestRate Interest rate for the loan in basis points (BPS).\n\t */\n\tevent LoanAdvertisementUpdated(\n\t\tuint256 loanAdvertisementId,\n\t\tbool isAvailable,\n\t\tuint256 maxLoanDuration,\n\t\tuint256 maxLoanAmount,\n\t\tuint256 interestRate\n\t);\n\n\t/**\n\t * @notice Emitted when a loan request is authorized.\n\t * @param loanRequestId ID of the loan request.\n\t * @param loanId ID of the loan.\n\t * @param borrower Address of the borrower.\n\t * @param duration Duration of the loan in seconds.\n\t * @param interestRate Interest rate for the loan in basis points (BPS).\n\t * @param loanAmount Amount of loan.\n\t * @param collateralChainId Chain ID of the collateral asset.\n\t * @param collateralAddress Address of the collateral asset.\n\t * @param collateralAmountOrId Amount or ID of the collateral asset.\n\t * @param collateralType Type of collateral (ERC20 or ERC721).\n\t */\n\tevent LoanRequestAuthorized(\n\t\tuint256 indexed loanRequestId,\n\t\tuint256 indexed loanId,\n\t\taddress indexed borrower,\n\t\tuint256 duration,\n\t\tuint256 interestRate,\n\t\tuint256 loanAmount,\n\t\tuint64 collateralChainId,\n\t\taddress collateralAddress,\n\t\tuint256 collateralAmountOrId,\n\t\tbool collateralType\n\t);\n\n\t/**\n\t * @notice Emitted when a loan is borrowed.\n\t * @param loanId ID of the loan.\n\t * @param borrower Address of the borrower.\n\t * @param duration Duration of the loan in seconds.\n\t * @param interestRate Interest rate for the loan in basis points (BPS).\n\t * @param loanAmount Amount of loan.\n\t * @param collateralChainId Chain ID of the collateral asset.\n\t * @param collateralAddress Address of the collateral asset.\n\t * @param collateralAmountOrId Amount or ID of the collateral asset.\n\t * @param collateralType Type of collateral (ERC20 or ERC721).\n\t */\n\tevent LoanBorrowed(\n\t\tuint256 indexed loanId,\n\t\taddress indexed borrower,\n\t\tuint256 duration,\n\t\tuint256 interestRate,\n\t\tuint256 loanAmount,\n\t\tuint64 collateralChainId,\n\t\taddress collateralAddress,\n\t\tuint256 collateralAmountOrId,\n\t\tbool collateralType\n\t);\n\n\t/**\n\t * @notice Emitted when a loan is repaid.\n\t * @param loanId ID of the loan.\n\t * @param borrower Address of the borrower.\n\t * @param loanAmount Amount of loan.\n\t * @param interestAmount Amount of interest.\n\t */\n\tevent LoanRepaid(\n\t\tuint256 indexed loanId,\n\t\taddress indexed borrower,\n\t\tuint256 loanAmount,\n\t\tuint256 interestAmount\n\t);\n\n\t/**\n\t * @notice Emitted when a loan is liquidated.\n\t * @param loanId ID of the loan.\n\t * @param borrower Address of the borrower.\n\t * @param liquidator Address of the liquidator.\n\t * @param loanAmount Amount of loan.\n\t * @param interestAmount Amount of interest.\n\t */\n\tevent LoanLiquidated(\n\t\tuint256 indexed loanId,\n\t\taddress indexed borrower,\n\t\taddress indexed liquidator,\n\t\tuint256 loanAmount,\n\t\tuint256 interestAmount\n\t);\n\n\tevent CrosschainLoanBorrowedInit(\n\t\tuint256 indexed loanId,\n\t\taddress indexed borrower,\n\t\tuint256 duration,\n\t\tuint256 interestRate,\n\t\tuint256 loanAmount,\n\t\tuint64 collateralChainId,\n\t\taddress collateralAddress,\n\t\tuint256 collateralAmountOrId,\n\t\tbool collateralType\n\t);\n\n\t/**\n\t * @notice Emitted when a loan is started.\n\t * @param loanId ID of the loan.\n\t * @param startTimestamp Timestamp when the loan was started.\n\t */\n\tevent LoanStarted(uint256 indexed loanId, uint256 startTimestamp);\n\n\t/// @notice Emitted when a loan advertisement is published.\n\terror UnauthorizedAccess(address caller);\n\n\t/// @notice Loan already borrowed error.\n\terror LoanAlreadyBorrowed(uint256 loanId);\n\n\t/// @notice Loan not active error.\n\terror LoanNotActive(uint256 loanId);\n\n\t/// @notice Wrong Borrower error.\n\terror WrongBorrower(address caller, address borrower);\n\n\t/// @notice Loan Still Active error.\n\terror LoanStillActive(uint256 loanId);\n\n\t/// @notice Only owner can call error.\n\terror OnlyOwnerCanCall(address sender);\n\n\t/// @notice Collateral Not Deposited error.\n\terror CollateralNotDeposited(uint256 loanId);\n\n\t/**\n\t * @notice Sets the loan parameters.\n\t * @param _maxLoanDuration The maximum duration of a loan in seconds.\n\t * @param _availableBorrowPowerPercent Percentage of total borrow power that is available for borrowing.\n\t * @param _maxLoanAmountPercentPerBorrower Maximum loan amount per borrower as a percentage of available borrow power.\n\t * @param _interestRate Interest rate for loans in basis points (BPS)\n\t */\n\tfunction setLoanParameters(\n\t\tuint256 _maxLoanDuration,\n\t\tuint256 _availableBorrowPowerPercent,\n\t\tuint256 _maxLoanAmountPercentPerBorrower,\n\t\tuint256 _interestRate\n\t) external;\n\n\t/**\n\t * @notice Returns the available borrow power.\n\t * @return availableBorrowPower The available borrow power.\n\t */\n\tfunction getAvailableBorrowPower()\n\t\texternal\n\t\tview\n\t\treturns (uint256 availableBorrowPower);\n\n\t/**\n\t * @notice Returns the maximum loan amount per borrower.\n\t * @return maxLoanAmountPerBorrower The maximum loan amount per borrower (in GHO tokens)\n\t */\n\tfunction getMaxLoanAmountPerBorrower()\n\t\texternal\n\t\tview\n\t\treturns (uint256 maxLoanAmountPerBorrower);\n\n\t/**\n\t * @notice Returns the number of loan advertisements.\n\t * @return loanAdvertisementsCount The number of loan advertisements.\n\t */\n\tfunction getLoanAdvertisementsCount() external view returns (uint256);\n\n\t/**\n\t * @notice Returns the loan advertisement ID at the specified index.\n\t * @param index The index of the loan advertisement ID.\n\t * @return loanAdvertisementId The loan advertisement ID.\n\t */\n\tfunction getLoanAdvertisementId(\n\t\tuint256 index\n\t) external view returns (uint256);\n\n\t/**\n\t * @notice Returns the loan advertisement IDs.\n\t * @return loanIds The loan advertisement IDs.\n\t */\n\tfunction getLoanAdvertisementIds() external view returns (uint256[] memory);\n\n\t/**\n\t * @notice Returns the loan advertisement data.\n\t * @param _loanId The loan advertisement ID.\n\t * @return loanAdvertisementData The loan advertisement data.\n\t */\n\tfunction getLoanAdvertisementData(\n\t\tuint256 _loanId\n\t)\n\t\texternal\n\t\tview\n\t\treturns (\n\t\t\tIGhoSafeLoanAdvertisementBookSepolia.LoanAdvertisement\n\t\t\t\tmemory loanAdvertisementData\n\t\t);\n\n\t/**\n\t * @notice Returns the loan data.\n\t * @param _loanId The loan ID.\n\t * @return loan The loan data.\n\t */\n\tfunction getLoanData(\n\t\tuint256 _loanId\n\t) external view returns (Loan memory loan);\n\n\t/**\n\t * @notice Publishes a loan advertisement.\n\t */\n\tfunction publishLoanAdvertisement() external;\n\n\t/**\n\t * @notice Updates the loan advertisement data.\n\t * @param _loanId The loan advertisement ID.\n\t * @param _isAvailable Whether the loan advertisement is available.\n\t */\n\tfunction updateLoanAdvertisementData(\n\t\tuint256 _loanId,\n\t\tbool _isAvailable\n\t) external;\n\n\t/**\n\t * @notice Returns whether a loan request is already authorized.\n\t * @param _loanRequestId ID of the loan request.\n\t * @return isAlreadyAuthorized Whether the loan request is already authorized.\n\t */\n\tfunction isRequestAlreadyAuthorized(\n\t\tuint256 _loanRequestId\n\t) external view returns (bool isAlreadyAuthorized);\n\n\t/**\n\t * @notice Authorizes a loan request.\n\t * @param _loanRequestId ID of the loan request.\n\t */\n\tfunction authorizeLoan(uint256 _loanRequestId) external;\n\n\t/**\n\t * @notice Starts a loan.\n\t * @param _loanId ID of the loan.\n\t */\n\tfunction borrow(uint256 _loanId) external;\n}\n"
    },
    "contracts/Sepolia/interfaces/ILoanSafeSepolia.sol": {
      "content": "// File: contracts/Sepolia/interfaces/ILoanSafeSepolia.sol\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\n/**\n * @title ILoanSafeSepolia Contract Interface\n * @author GhoSafe Protocol\n * @notice Interface for the LoanSafeSepolia contract\n * @dev This interface should be implemented by the LoanSafeSepolia contract.\n */\ninterface ILoanSafeSepolia {\n\t/// @notice Unauthorized access error.\n\terror UnauthorizedAccess(address caller);\n\n\t/**\n\t * @notice Emitted when a loan is started.\n\t * @param loanId ID of the loan.\n\t * @param startTimestamp Timestamp when the loan was started.\n\t */\n\tevent LoanStarted(uint256 indexed loanId, uint256 startTimestamp);\n\n\t/**\n\t * @notice Checks if the collateral of a loan is owned by the contract.\n\t * @param _loanId ID of the loan.\n\t * @return isValid True if the collateral is owned by the contract.\n\t */\n\tfunction checkLoanCollateral(\n\t\tuint256 _loanId\n\t) external view returns (bool isValid);\n\n\t/**\n\t * @notice Sends back the collateral of a loan.\n\t * @param _loanId ID of the loan.\n\t */\n\tfunction sendBackCollateral(uint256 _loanId) external;\n\n\t/**\n\t * @notice Seizes the collateral of a loan.\n\t * @param _loanId ID of the loan.\n\t * @param _receiver Address of the receiver.\n\t */\n\tfunction seizeCollateral(uint256 _loanId, address _receiver) external;\n\n\t/**\n\t * @dev The contract should be able to receive ERC721 tokens.\n\t */\n\tfunction onERC721Received(\n\t\taddress,\n\t\taddress,\n\t\tuint256,\n\t\tbytes calldata\n\t) external pure returns (bytes4);\n}\n"
    },
    "contracts/Sepolia/interfaces/IMailboxSepolia.sol": {
      "content": "// File: contracts/Sepolia/interfaces/IMailboxSepolia.sol\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\n/**\n * @title IMailboxSepolia Contract Interface\n * @author GhoSafe Protocol\n * @notice Interface for the MailboxSepolia contract\n * @dev This interface should be implemented by the MailboxSepolia contract.\n */\ninterface IMailboxSepolia {\n\t/**\n\t * @notice Loan request struct\n\t * @param amountToBorrow Amount of loan to borrow in GHO tokens.\n     * @param loanDuration Duration of the loan in seconds.\n\t * @param collateralAmountOrId Amount or ID of the collateral asset.\n\t * @param collateralAddress Address of the collateral asset.\n\t * @param borrower Address of the borrower.\n\t * @param collateralChainId Chain ID of the collateral asset.\n\t * @param collateralType Type of the collateral asset: 0 for ERC20, 1 for ERC721.\n\t */\n\tstruct LoanRequest {\n\t\tuint256 amountToBorrow;\n        uint256 loanDuration;\n\t\tuint256 collateralAmountOrId;\n\t\taddress collateralAddress;\n\t\taddress borrower;\n\t\tuint64 collateralChainId;\n\t\tbool collateralType;\n\t}\n\n\t/**\n\t * @notice Emitted when a loan request is created.\n\t * @param loanRequestId ID of the loan request.\n\t * @param borrower Address of the borrower.\n\t * @param collateralAmountOrId Amount or ID of the collateral asset.\n\t * @param collateralAddress Address of the collateral asset.\n\t * @param collateralType Type of the collateral asset: 0 for ERC20, 1 for ERC721.\n\t * @param collateralChainId Chain ID of the collateral asset.\n\t * @param amountToBorrow Amount of loan to borrow in GHO tokens.\n     * @param loanDuration Duration of the loan in seconds.\n\t */\n\tevent LoanRequestCreated(\n\t\tuint256 indexed loanRequestId,\n\t\taddress indexed borrower,\n\t\tuint256 collateralAmountOrId,\n\t\taddress collateralAddress,\n\t\tuint64 collateralChainId,\n\t\tbool collateralType,\n\t\tuint256 amountToBorrow,\n        uint256 loanDuration\n\t);\n    \n    /// @notice No GhoSafeID Found error\n    error NoGhoSafeIDFound(address caller);\n\n\t/**\n\t * @notice Creates a loan request.\n\t * @param _collateralAmountOrId Amount or ID of the collateral asset.\n\t * @param _collateralAddress Address of the collateral asset.\n\t * @param _collateralType Type of the collateral asset: 0 for ERC20, 1 for ERC721.\n\t * @param _collateralChainId Chain ID of the collateral asset.\n\t * @param _amountToBorrow Amount of loan to borrow in GHO tokens.\n     * @param _loanDuration Duration of the loan in seconds.\n\t * @return loanRequestId ID of the loan request.\n\t */\n\tfunction loanRequest(\n\t\tuint256 _collateralAmountOrId,\n\t\taddress _collateralAddress,\n\t\tbool _collateralType,\n\t\tuint64 _collateralChainId,\n\t\tuint256 _amountToBorrow,\n        uint256 _loanDuration\n\t) external returns (uint256 loanRequestId);\n\n\t/**\n\t * @notice Returns the loan request.\n\t * @param _loanRequestId ID of the loan request.\n\t * @return loanRequest Loan request struct.\n\t */\n\tfunction getLoanRequest(\n\t\tuint256 _loanRequestId\n\t) external view returns (LoanRequest memory loanRequest);\n}\n"
    },
    "contracts/Sepolia/interfaces/IMessengerSepolia.sol": {
      "content": "// File: contracts/Sepolia/interfaces/IMessengerSepolia.sol\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\n/**\n * @title IMessengerSepolia Contract Interface\n * @author GhoSafe Protocol\n * @notice Interface for the MessengerSepolia contract\n * @dev This interface should be implemented by the MessengerSepolia contract.\n */\ninterface IMessengerSepolia {\n\t/**\n\t * @notice Struct for loan data\n\t * @param messageId Message ID\n\t * @param loanId ID of the loan\n\t * @param collateralIdOrAmount Collateral ID or amount\n\t * @param collateralChainId Collateral chain ID\n\t * @param action Action\n\t * @param collateralType Collateral type\n\t * @param collateralAddress Collateral address\n\t * @param borrower Borrower address\n\t */\n\tstruct LoanData {\n\t\tbytes32 lastReceivedMessageId;\n\t\tbytes32 lastSentMessageId;\n\t\tuint8 lastAction;\n\t\tbool isSuccessful;\n\t}\n\n\t/**\n\t * @notice Struct for request\n\t * @param loanId ID of the loan\n\t * @param collateralIdOrAmount Collateral ID or amount\n\t * @param action Action\n\t * @param collateralType Collateral type\n\t * @param collateralAddress Collateral address\n\t * @param borrower Borrower address\n\t */\n\tstruct Request {\n\t\tuint256 loanId;\n\t\tuint256 collateralIdOrAmount;\n\t\tuint8 action;\n\t\tbool collateralType;\n\t\taddress collateralAddress;\n\t\taddress borrower;\n\t}\n\n\t/**\n\t * @notice Struct for response\n\t * @param loanId ID of the loan\n\t * @param action Action\n\t * @param isSuccessful True if the response is successful\n\t */\n\tstruct Response {\n\t\tuint256 loanId;\n\t\tuint8 action;\n\t\tbool isSuccessful;\n\t}\n\n\t/// @notice Not enough balance error.\n\terror NotEnoughBalance(uint256 currentBalance, uint256 calculatedFees);\n\n\t/// @notice Nothing to withdraw error.\n\terror NothingToWithdraw();\n\n\t/// @notice Destination chain not allowlisted error.\n\terror DestinationChainNotAllowlisted(uint64 destinationChainSelector);\n\n\t/// @notice Source chain not allowlisted error.\n\terror SourceChainNotAllowlisted(uint64 sourceChainSelector);\n\n\t/// @notice Sender not allowlisted error.\n\terror SenderNotAllowlisted(address sender);\n\n\t/// @notice Only owner can call error.\n\terror OnlyOwnerCanCall(address sender);\n\n\t/// @notice Only loan manager can call error.\n\terror OnlyLoanManagerCanCall(address sender);\n\n\t/**\n\t * @notice Emitted when a Deposit Request is sent.\n\t * @param messageId ID of the message.\n\t * @param loanId ID of the loan.\n\t * @param collateralIdOrAmount Collateral ID or amount.\n\t * @param collateralChainId Collateral chain ID.\n\t * @param action Action.\n\t * @param collateralType Collateral type.\n\t * @param collateralAddress Collateral address.\n\t * @param borrower Borrower address.\n\t */\n\tevent RequestSent(\n\t\tbytes32 indexed messageId,\n\t\tuint256 indexed loanId,\n\t\tuint256 collateralIdOrAmount,\n\t\tuint64 collateralChainId,\n\t\tuint8 action,\n\t\tbool collateralType,\n\t\taddress collateralAddress,\n\t\taddress borrower\n\t);\n\n\t/**\n\t * @notice Emitted when a Message is received.\n\t * @param messageId ID of the message.\n\t * @param sourceChainSelector Source chain ID.\n\t * @param sender Sender address.\n\t * @param loanId ID of the loan.\n\t * @param action Action.\n\t * @param isSuccessful True if the response is successful.\n\t */\n\tevent MessageReceived(\n\t\tbytes32 indexed messageId, // The unique ID of the CCIP message.\n\t\tuint64 indexed sourceChainSelector, // The chain selector of the source chain.\n\t\taddress sender, // The address of the sender from the source chain.\n\t\tuint256 loanId,\n\t\tuint16 action,\n\t\tbool isSuccessful\n\t);\n\n\t/**\n\t * @notice Allows the contract owner to update the allowlist status of a destination chain for transactions.\n\t * @param _destinationChainSelector The identifier (aka selector) for the destination blockchain.\n\t * @param _allowed The new allowlist status.\n\t * @dev This function reverts if the sender is not the owner.\n\t */\n\tfunction allowlistDestinationChain(\n\t\tuint64 _destinationChainSelector,\n\t\tbool _allowed\n\t) external;\n\n\t/**\n\t * @notice Returns the loan data for a given loan ID.\n\t * @param _loanId ID of the loan.\n\t * @return LoanData Loan data.\n\t */\n\tfunction getLoanData(\n\t\tuint256 _loanId\n\t) external view returns (LoanData memory);\n\n\t/**\n\t * @notice Allows the contract owner to update the allowlist status of a source chain for transactions.\n\t * @param _sourceChainSelector The identifier (aka selector) for the source blockchain.\n\t * @param _allowed The new allowlist status.\n\t * @dev This function reverts if the sender is not the owner.\n\t */\n\tfunction allowlistSourceChain(\n\t\tuint64 _sourceChainSelector,\n\t\tbool _allowed\n\t) external;\n\n\t/**\n\t * @notice Allows the contract owner to update the allowlist status of a sender for transactions.\n\t * @param _sender The address of the sender.\n\t * @param _allowed The new allowlist status.\n\t * @dev This function reverts if the sender is not the owner.\n\t */\n\tfunction allowlistSender(address _sender, bool _allowed) external;\n\n\t/**\n\t * @notice Send a request to another chain.\n\t * @dev The contract should have sufficient LINK.\n\t * @param _destinationChainSelector The identifier (aka selector) for the destination blockchain.\n\t * @param _receiver The address of the recipient on the destination blockchain.\n\t */\n\tfunction sendRequest(\n\t\tuint64 _destinationChainSelector,\n\t\taddress _receiver,\n\t\tRequest calldata _collateralDepositRequest\n\t) external;\n}\n"
    },
    "contracts/Sepolia/interfaces/ISafeSepolia.sol": {
      "content": "// File: contracts/Sepolia/interfaces/ISafeSepolia.sol\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\n/**\n * @title ISafeSepolia Contract Interface\n * @author GhoSafe Protocol\n * @notice Interface for the SafeSepolia contract\n * @dev This interface should be implemented by the SafeSepolia contract.\n */\ninterface ISafeSepolia {\n\t/// @notice ETH transfer failed error\n\terror ETHTtransferFailed(bytes data);\n\t/// @notice Not enough balance error\n\terror NotEnoughBalance(address token, uint256 amount, uint256 balance);\n\t/// @notice Unauthorized access error\n\terror UnauthorizedAccess(address caller);\n\n\t/**\n\t * @notice Event emitted when a new owner is added\n\t * @param owner Address of the new owner\n\t */\n\tevent OwnerAdded(address indexed owner);\n\n\t/**\n\t * @notice Event emitted when an owner is removed\n\t * @param owner Address of the removed owner\n\t */\n\tevent OwnerRemoved(address indexed owner);\n\n\t/**\n\t * @notice Event emitted when ETH is withdrawn from the safe\n\t * @param amount Amount of ETH withdrawn\n\t * @param to Address that received the ETH\n\t */\n\tevent ETHWithdrawnFromSafe(uint256 amount, address indexed to);\n\n\t/**\n\t * @notice Event emitted when a ERC20 is withdrawn from the safe\n\t * @param token Address of the token withdrawn\n\t * @param amount Amount of the token withdrawn\n\t * @param to Address that received the token\n\t */\n\tevent ERC20WithdrawnFromSafe(\n\t\taddress indexed token,\n\t\tuint256 amount,\n\t\taddress indexed to\n\t);\n\n\t/**\n\t * @notice Event emitted when a ERC20 is supplied to Aave\n\t * @param token Address of the token supplied\n\t * @param amount Amount of the token supplied\n\t */\n\tevent TokenSuppliedToAave(address indexed token, uint256 amount);\n\n\t/**\n\t * @notice Event emitted when a ERC20 is withdrawn from Aave\n\t * @param token Address of the token withdrawn\n\t * @param amount Amount of the token withdrawn\n\t */\n\tevent TokenWithdrawnFromAave(address indexed token, uint256 amount);\n\n\t/**\n\t * @notice Event emitted when a ERC20 is borrowed from Aave\n\t * @param token Address of the token borrowed\n\t * @param amount Amount of the token borrowed\n\t */\n\tevent TokenBorrowedFromAave(address indexed token, uint256 amount);\n\n\t/**\n\t * @notice Event emitted when a ERC20 is repaid to Aave\n\t * @param token Address of the token repaid\n\t * @param amount Amount of the token repaid\n\t */\n\tevent TokenRepaidToAave(address indexed token, uint256 amount);\n\n\t/**\n\t * @notice Event emitted ETH is received by the contract\n\t * @param amount Amount of ETH received\n\t * @param from Address that sent the ETH\n\t */\n\tevent ReceivedETH(uint256 amount, address indexed from);\n\n\t/**\n\t * @notice Event emitted when a delegatee is approved to spend a specific amount of GHO\n\t * @param delegatee Address of the delegatee\n\t * @param amount Amount of GHO approved\n\t */\n\tevent CreditDelegateApproved(address indexed delegatee, uint256 amount);\n\n\t/**\n\t * @notice Returns the balances of the specified tokens\n\t * @param _tokens Addresses of the ERC20 tokens to check\n\t * @return balances Balances of the specified tokens\n\t */\n\tfunction getSafeBalances(\n\t\taddress[] calldata _tokens\n\t) external view returns (uint256[] memory balances);\n\n\t/**\n\t * @notice Withdraws a specific amount of ETH from the contract to a specified address.\n\t * @param _to Address that will receive the ETH\n\t * @param _amount Amount of ETH to withdraw\n\t */\n\tfunction withdrawETHFromSafe(\n\t\taddress payable _to,\n\t\tuint256 _amount\n\t) external payable;\n\n\t/**\n\t * @notice Withdraws a specific amount of an ERC20 token from the contract to a specified address.\n\t * @param _to Address that will receive the token\n\t * @param _token Address of the ERC20 token\n\t * @param _amount Amount of the token to withdraw\n\t */\n\tfunction withdrawFromSafe(\n\t\taddress payable _to,\n\t\taddress _token,\n\t\tuint256 _amount\n\t) external;\n\n\t/**\n\t * @notice Supplies a specific amount of an ERC20 token to Aave.\n\t * @param _token Address of the ERC20 token\n\t * @param _amount Amount of the token to supply\n\t */\n\tfunction supplyToAave(address _token, uint256 _amount) external;\n\n\t/**\n\t * @notice Withdraws a specific amount of an ERC20 token from Aave.\n\t * @param _token Address of the ERC20 token\n\t * @param _amount Amount of the token to withdraw\n\t */\n\tfunction withdrawFromAave(address _token, uint256 _amount) external;\n\n\t/**\n\t * @notice Borrows a specific amount of an ERC20 token from Aave.\n\t * @param _token Address of the ERC20 token\n\t * @param _amount Amount of the token to borrow\n\t * @param _interestRateMode Interest rate mode for the borrow\n\t */\n\tfunction borrowFromAave(\n\t\taddress _token,\n\t\tuint256 _amount,\n\t\tuint256 _interestRateMode\n\t) external;\n\n\t/**\n\t * @notice Repays a specific amount of an ERC20 token to Aave.\n\t * @param _token Address of the ERC20 token\n\t * @param _amount Amount of the token to repay\n\t * @param _rateMode Interest rate mode for the repay\n\t */\n\tfunction repayToAave(\n\t\taddress _token,\n\t\tuint256 _amount,\n\t\tuint256 _rateMode\n\t) external;\n\n\t/**\n\t * @notice Borrows GHO from Aave.\n\t * @param _amount Amount of GHO to borrow\n\t */\n\tfunction borrowGho(uint256 _amount) external;\n\n\t/**\n\t * @notice Repays GHO to Aave.\n\t * @param _amount Amount of GHO to repay\n\t */\n\tfunction repayGho(uint256 _amount) external;\n\n\t/**\n\t * @notice Approves a delegatee to spend a specific amount of GHO.\n\t * @param _delegatee Address of the delegatee\n\t * @param _amount Amount of GHO to approve\n\t */\n\tfunction approveDelegateCreditGho(\n\t\taddress _delegatee,\n\t\tuint256 _amount\n\t) external;\n\n\t/// @notice Fallback function to receive ETH with data\n\treceive() external payable;\n\n\t/// @notice Fallback function to receive ETH without data\n\tfallback() external payable;\n}\n"
    },
    "contracts/Sepolia/users/AccessManagerSepolia.sol": {
      "content": "// File: contracts/Sepolia/users/AccessManagerSepolia.sol\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { AccessControlDefaultAdminRules } from \"@openzeppelin/contracts/access/extensions/AccessControlDefaultAdminRules.sol\";\n\n/**\n * @title AccessManagerSepolia Contract\n * @author GhoSafe Protocol\n * @notice Contract for setting up access to users contracts\n */\ncontract AccessManagerSepolia is AccessControlDefaultAdminRules {\n\t/// @notice Owner role\n\tbytes32 public constant OWNER_ROLE = keccak256(\"OWNER_ROLE\");\n\n\t/// @notice Unauthorized access error.\n\terror UnauthorizedAccess(address caller);\n\n\t/**\n\t * @notice Constructor\n\t * @param _owner Owner address\n\t */\n\tconstructor(\n\t\taddress _owner\n\t)\n\t\tAccessControlDefaultAdminRules(\n\t\t\t3 days,\n\t\t\tmsg.sender // Explicit initial `DEFAULT_ADMIN_ROLE` holder\n\t\t)\n\t{\n\t\t_grantRole(OWNER_ROLE, _owner);\n\t}\n\n\t/**\n\t * @dev Throws if called by any account other than the default admin.\n\t */\n\tmodifier onlyAdmin() {\n\t\tif (!hasRole(DEFAULT_ADMIN_ROLE, _msgSender())) {\n\t\t\trevert UnauthorizedAccess(_msgSender());\n\t\t}\n\t\t_;\n\t}\n\n\t/**\n\t * @notice Grant owner role to a new address\n\t * @param _newOwner Address of the new owner\n\t */\n\tfunction grantOwnerRole(address _newOwner) external onlyAdmin {\n\t\t_grantRole(OWNER_ROLE, _newOwner);\n\t}\n\n\t/**\n\t * @notice Revoke owner role from an address\n\t * @param _oldOwner Address of the old owner\n\t */\n\tfunction revokeOwnerRole(address _oldOwner) external onlyAdmin {\n\t\t_revokeRole(OWNER_ROLE, _oldOwner);\n\t}\n}\n"
    },
    "contracts/Sepolia/users/LoanManagerSepolia.sol": {
      "content": "// File: contracts/Sepolia/users/LoanManagerSepolia.sol\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC721 } from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport { EnumerableSet } from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\nimport { IAccessManagerSepolia } from \"../interfaces/IAccessManagerSepolia.sol\";\nimport { IGhoSafeLoanAdvertisementBookSepolia } from \"../interfaces/IGhoSafeLoanAdvertisementBookSepolia.sol\";\nimport { ILoanManagerSepolia } from \"../interfaces/ILoanManagerSepolia.sol\";\nimport { ILoanSafeSepolia } from \"../interfaces/ILoanSafeSepolia.sol\";\nimport { IMailboxSepolia } from \"../interfaces/IMailboxSepolia.sol\";\nimport { ISafeSepolia } from \"../interfaces/ISafeSepolia.sol\";\nimport { IMessengerSepolia } from \"../interfaces/IMessengerSepolia.sol\";\nimport { LoanSafeSepolia } from \"./LoanSafeSepolia.sol\";\nimport { MessengerSepolia } from \"./MessengerSepolia.sol\";\n\n/**\n * @title LoanManagerSepolia Contract\n * @author GhoSafe Protocol\n * @notice Contract for managing loans\n * @dev This contract should be deployed by the SafeSepolia contract.\n */\ncontract LoanManagerSepolia is ILoanManagerSepolia, ReentrancyGuard {\n\tusing EnumerableSet for EnumerableSet.UintSet;\n\tusing SafeERC20 for IERC20;\n\n\t/// @notice The maximum duration of a loan in seconds.\n\tuint256 public maxLoanDuration;\n\n\t/// @notice Percentage of total borrow power that is available for borrowing.\n\tuint256 public availableBorrowPowerPercent;\n\n\t/// @notice Maximum loan amount per borrower as a percentage of available borrow power.\n\tuint256 public maxLoanAmountPercentPerBorrower;\n\n\t/// @notice Interest rate for loans in basis points (BPS)\n\tuint256 public interestRate;\n\n\t/// @notice Safe contract.\n\tISafeSepolia public immutable USER_SAFE;\n\n\t/// @notice Access manager contract.\n\tIAccessManagerSepolia public immutable USER_ACCESS_MANAGER;\n\n\t/// @notice Mailbox contract.\n\tIMailboxSepolia public immutable USER_MAILBOX;\n\n\t/// @notice Loan Safe contract.\n\tILoanSafeSepolia public immutable USER_LOAN_SAFE;\n\n\t/// @notice Messenger contract.\n\tIMessengerSepolia public immutable USER_MESSENGER;\n\n\t/// @dev Loan advertisement book contract.\n\tIGhoSafeLoanAdvertisementBookSepolia\n\t\tpublic immutable LOAN_ADVERTISEMENT_BOOK;\n\n\t/// @dev Debt Gho token contract: https://sepolia.etherscan.io/address/0x67ae46EF043F7A4508BD1d6B94DB6c33F0915844\n\tIERC20 private immutable DEBT_GHO_TOKEN;\n\n\t/// @dev Gho token contract: https://sepolia.etherscan.io/address/0xc4bF5CbDaBE595361438F8c6a187bDc330539c60\n\tIERC20 internal immutable GHO_TOKEN;\n\n\t/// @dev Set of loan advertisement IDs.\n\tEnumerableSet.UintSet private _loanAdvertisementIds;\n\n\t/// @notice Loans mapping.\n\tmapping(uint256 => Loan) private loans;\n\n\t/// @notice Messengers mapping (chain ID => address)\n\tmapping(uint64 => address) public messengers;\n\n\t/// @dev Loans counter.\n\tuint256 private _loanCounter;\n\n\t/**\n\t * @notice Constructor\n\t * @param _accessManager Address of the access manager contract.\n\t * @param _mailbox Address of the mailbox contract.\n\t * @param _loanAdvertisementBook Address of the loan advertisement book contract.\n\t * @param _ghoToken Address of the GHO token.\n\t * @param _debtGhoToken Address of the debt GHO token.\n\t * @param _router Address of the router contract.\n\t * @param _link Address of the LINK token.\n\t */\n\tconstructor(\n\t\tIAccessManagerSepolia _accessManager,\n\t\taddress _mailbox,\n\t\taddress _loanAdvertisementBook,\n\t\taddress _ghoToken,\n\t\taddress _debtGhoToken,\n\t\taddress _router,\n\t\taddress _link\n\t) {\n\t\tGHO_TOKEN = IERC20(_ghoToken);\n\t\tDEBT_GHO_TOKEN = IERC20(_debtGhoToken);\n\t\tUSER_SAFE = ISafeSepolia(payable(msg.sender));\n\t\tUSER_ACCESS_MANAGER = _accessManager;\n\t\tUSER_MAILBOX = IMailboxSepolia(_mailbox);\n\t\tLOAN_ADVERTISEMENT_BOOK = IGhoSafeLoanAdvertisementBookSepolia(\n\t\t\t_loanAdvertisementBook\n\t\t);\n\t\tUSER_LOAN_SAFE = ILoanSafeSepolia(address(new LoanSafeSepolia()));\n\t\tUSER_MESSENGER = IMessengerSepolia(\n\t\t\taddress(new MessengerSepolia(_router, _link, _accessManager))\n\t\t);\n\t}\n\n\tmodifier onlyOwner() {\n\t\tif (!USER_ACCESS_MANAGER.hasRole(keccak256(\"OWNER_ROLE\"), msg.sender)) {\n\t\t\trevert OnlyOwnerCanCall(msg.sender);\n\t\t}\n\t\t_;\n\t}\n\n\t/**\n\t * @notice Returns the available borrow power.\n\t * @return availableBorrowPower The available borrow power.\n\t */\n\tfunction getAvailableBorrowPower()\n\t\tpublic\n\t\tview\n\t\treturns (uint256 availableBorrowPower)\n\t{\n\t\tuint256 totalBorrowPower = DEBT_GHO_TOKEN.balanceOf(address(USER_SAFE));\n\t\tavailableBorrowPower =\n\t\t\t(totalBorrowPower * availableBorrowPowerPercent) /\n\t\t\t100;\n\t}\n\n\t/**\n\t * @notice Returns the maximum loan amount per borrower.\n\t * @return maxLoanAmountPerBorrower The maximum loan amount per borrower (in GHO tokens)\n\t */\n\tfunction getMaxLoanAmountPerBorrower()\n\t\tpublic\n\t\tview\n\t\treturns (uint256 maxLoanAmountPerBorrower)\n\t{\n\t\tuint256 totalBorrowPower = DEBT_GHO_TOKEN.balanceOf(address(USER_SAFE));\n\t\tuint256 availableBorrowPower = (totalBorrowPower *\n\t\t\tavailableBorrowPowerPercent) / 100;\n\t\tmaxLoanAmountPerBorrower =\n\t\t\t(availableBorrowPower * maxLoanAmountPercentPerBorrower) /\n\t\t\t100;\n\t}\n\n\t/**\n\t * @notice Returns the number of loan advertisements.\n\t * @return loanAdvertisementsCount The number of loan advertisements.\n\t */\n\tfunction getLoanAdvertisementsCount() external view returns (uint256) {\n\t\treturn _loanAdvertisementIds.length();\n\t}\n\n\t/**\n\t * @notice Returns the loan advertisement ID at the specified index.\n\t * @param index The index of the loan advertisement ID.\n\t * @return loanAdvertisementId The loan advertisement ID.\n\t */\n\tfunction getLoanAdvertisementId(\n\t\tuint256 index\n\t) external view returns (uint256) {\n\t\treturn _loanAdvertisementIds.at(index);\n\t}\n\n\t/**\n\t * @notice Returns the loan advertisement IDs.\n\t * @return loanIds The loan advertisement IDs.\n\t */\n\tfunction getLoanAdvertisementIds()\n\t\texternal\n\t\tview\n\t\treturns (uint256[] memory)\n\t{\n\t\tuint256[] memory loanIds = new uint256[](\n\t\t\t_loanAdvertisementIds.length()\n\t\t);\n\t\tfor (uint256 i = 0; i < _loanAdvertisementIds.length(); i++) {\n\t\t\tloanIds[i] = _loanAdvertisementIds.at(i);\n\t\t}\n\t\treturn loanIds;\n\t}\n\n\t/**\n\t * @notice Returns the loan advertisement data.\n\t * @param _loanId The loan advertisement ID.\n\t * @return loanAdvertisementData The loan advertisement data.\n\t */\n\tfunction getLoanAdvertisementData(\n\t\tuint256 _loanId\n\t)\n\t\texternal\n\t\tview\n\t\treturns (\n\t\t\tIGhoSafeLoanAdvertisementBookSepolia.LoanAdvertisement\n\t\t\t\tmemory loanAdvertisementData\n\t\t)\n\t{\n\t\tloanAdvertisementData = LOAN_ADVERTISEMENT_BOOK\n\t\t\t.getLoanAdvertisementData(_loanId);\n\t}\n\n\t/**\n\t * @notice Returns the loan data.\n\t * @param _loanId The loan ID.\n\t * @return loan The loan data.\n\t */\n\tfunction getLoanData(\n\t\tuint256 _loanId\n\t) external view returns (Loan memory loan) {\n\t\tloan = loans[_loanId];\n\t}\n\n\t/**\n\t * @notice Returns the total interest and the loan amount with interest.\n\t * @param _loanId The loan ID.\n\t * @return totalInterest The total interest for the loan.\n\t * @return loanAmountWithInterest The loan amount with interest.\n\t */\n\tfunction getTotalInterest(\n\t\tuint256 _loanId\n\t)\n\t\texternal\n\t\tview\n\t\treturns (uint256 totalInterest, uint256 loanAmountWithInterest)\n\t{\n\t\tLoan memory loan = loans[_loanId];\n\t\ttotalInterest = (loan.loanAmount * loan.interestRate) / 10000;\n\t\tloanAmountWithInterest = loan.loanAmount + totalInterest;\n\t}\n\n\t/**\n\t * @notice Returns the remaining loan time.\n\t * @param _loanId The loan ID.\n\t * @return remainingLoanTime The remaining loan time.\n\t */\n\tfunction getRemainingLoanTime(\n\t\tuint256 _loanId\n\t) external view returns (uint256 remainingLoanTime) {\n\t\tLoan memory loan = loans[_loanId];\n\t\tremainingLoanTime =\n\t\t\tloan.startTimestamp +\n\t\t\tloan.duration -\n\t\t\tblock.timestamp;\n\t}\n\n\t/**\n\t * @notice Sets the loan parameters.\n\t * @param _maxLoanDuration The maximum duration of a loan in seconds.\n\t * @param _availableBorrowPowerPercent Percentage of total borrow power that is available for borrowing.\n\t * @param _maxLoanAmountPercentPerBorrower Maximum loan amount per borrower as a percentage of available borrow power.\n\t * @param _interestRate Interest rate for loans in basis points (BPS)\n\t */\n\tfunction setLoanParameters(\n\t\tuint256 _maxLoanDuration,\n\t\tuint256 _availableBorrowPowerPercent,\n\t\tuint256 _maxLoanAmountPercentPerBorrower,\n\t\tuint256 _interestRate\n\t) external onlyOwner {\n\t\tmaxLoanDuration = _maxLoanDuration;\n\t\tavailableBorrowPowerPercent = _availableBorrowPowerPercent;\n\t\tmaxLoanAmountPercentPerBorrower = _maxLoanAmountPercentPerBorrower;\n\t\tinterestRate = _interestRate;\n\t\temit LoanParametersUpdated(\n\t\t\t_maxLoanDuration,\n\t\t\t_availableBorrowPowerPercent,\n\t\t\t_maxLoanAmountPercentPerBorrower\n\t\t);\n\t}\n\n\t/**\n\t * @notice Sets the messenger address for a chain ID.\n\t * @param _chainId Chain ID.\n\t * @param _messengerAddress Address of the messenger contract.\n\t */\n\tfunction setMessengerAddress(\n\t\tuint64 _chainId,\n\t\taddress _messengerAddress\n\t) external onlyOwner {\n\t\tmessengers[_chainId] = _messengerAddress;\n\t}\n\n\t/**\n\t * @notice Publishes a loan advertisement.\n\t */\n\tfunction publishLoanAdvertisement() external onlyOwner {\n\t\tuint256 maxLoanAmountPerBorrower = getMaxLoanAmountPerBorrower();\n\n\t\tuint256 loanAdvertisementId = LOAN_ADVERTISEMENT_BOOK\n\t\t\t.publishLoanAdvertisement(\n\t\t\t\tmaxLoanAmountPerBorrower,\n\t\t\t\tmaxLoanDuration,\n\t\t\t\tinterestRate,\n\t\t\t\taddress(USER_SAFE),\n\t\t\t\taddress(this)\n\t\t\t);\n\n\t\t_loanAdvertisementIds.add(loanAdvertisementId);\n\n\t\temit LoanAdvertisementPublished(\n\t\t\tloanAdvertisementId,\n\t\t\tmaxLoanDuration,\n\t\t\tmaxLoanAmountPerBorrower,\n\t\t\tinterestRate\n\t\t);\n\t}\n\n\t/**\n\t * @notice Updates the loan advertisement data.\n\t * @param _loanAdvertisementId The loan advertisement ID.\n\t * @param _isAvailable Whether the loan advertisement is available.\n\t */\n\tfunction updateLoanAdvertisementData(\n\t\tuint256 _loanAdvertisementId,\n\t\tbool _isAvailable\n\t) external onlyOwner {\n\t\tuint256 maxLoanAmountPerBorrower = getMaxLoanAmountPerBorrower();\n\n\t\tLOAN_ADVERTISEMENT_BOOK.updateLoanAdvertisementData(\n\t\t\t_loanAdvertisementId,\n\t\t\tmaxLoanAmountPerBorrower,\n\t\t\tmaxLoanDuration,\n\t\t\tinterestRate,\n\t\t\t_isAvailable\n\t\t);\n\n\t\temit LoanAdvertisementUpdated(\n\t\t\t_loanAdvertisementId,\n\t\t\t_isAvailable,\n\t\t\tmaxLoanDuration,\n\t\t\tmaxLoanAmountPerBorrower,\n\t\t\tinterestRate\n\t\t);\n\t}\n\n\t/**\n\t * @notice Returns whether a loan request is already authorized.\n\t * @param _loanRequestId ID of the loan request.\n\t * @return isAlreadyAuthorized Whether the loan request is already authorized.\n\t */\n\tfunction isRequestAlreadyAuthorized(\n\t\tuint256 _loanRequestId\n\t) external view returns (bool isAlreadyAuthorized) {\n\t\tfor (uint256 i = 0; i < _loanCounter; i++) {\n\t\t\tLoan storage loan = loans[i];\n\t\t\tif (loan.loanRequestId == _loanRequestId) {\n\t\t\t\tisAlreadyAuthorized = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @notice Authorizes a loan request.\n\t * @param _loanRequestId ID of the loan request.\n\t */\n\tfunction authorizeLoan(uint256 _loanRequestId) external onlyOwner {\n\t\tIMailboxSepolia.LoanRequest memory loanRequest = USER_MAILBOX\n\t\t\t.getLoanRequest(_loanRequestId);\n\n\t\tuint256 loanId = _loanCounter++;\n\n\t\tloans[loanId] = Loan(\n\t\t\tloanId,\n\t\t\t_loanRequestId,\n\t\t\t0,\n\t\t\tloanRequest.loanDuration,\n\t\t\tinterestRate,\n\t\t\tloanRequest.amountToBorrow,\n\t\t\tloanRequest.collateralAmountOrId,\n\t\t\tloanRequest.collateralChainId,\n\t\t\tloanRequest.collateralAddress,\n\t\t\tloanRequest.collateralType,\n\t\t\tloanRequest.borrower,\n\t\t\tfalse\n\t\t);\n\n\t\temit LoanRequestAuthorized(\n\t\t\t_loanRequestId,\n\t\t\tloanId,\n\t\t\tloanRequest.borrower,\n\t\t\tloanRequest.loanDuration,\n\t\t\tinterestRate,\n\t\t\tloanRequest.amountToBorrow,\n\t\t\tloanRequest.collateralChainId,\n\t\t\tloanRequest.collateralAddress,\n\t\t\tloanRequest.collateralAmountOrId,\n\t\t\tloanRequest.collateralType\n\t\t);\n\t}\n\n\t/**\n\t * @notice Initializes a loan with crosschain collateral. This function should be called by the borrower before calling `borrowWhithCrosschainCollateral`.\n\t * @notice The borrower should approve the collateral amount to be transferred by the safe contract on the collateral chain before calling this function.\n\t * @param _loanId ID of the loan.\n\t */\n\tfunction initBorrowWhithCrosschainCollateral(\n\t\tuint256 _loanId\n\t) external nonReentrant {\n\t\t// Verify that the loan is not active.\n\t\tLoan memory loan = loans[_loanId];\n\t\tif (loan.startTimestamp != 0) {\n\t\t\trevert LoanAlreadyBorrowed(_loanId);\n\t\t}\n\t\tif (loan.borrower != msg.sender) {\n\t\t\trevert WrongBorrower(msg.sender, loan.borrower);\n\t\t}\n\n\t\t// Initialize the loan.\n\t\tUSER_MESSENGER.sendRequest(\n\t\t\tloan.collateralChainId,\n\t\t\tmessengers[loan.collateralChainId],\n\t\t\tIMessengerSepolia.Request({\n\t\t\t\tloanId: _loanId,\n\t\t\t\tcollateralIdOrAmount: loan.collateralAmountOrId,\n\t\t\t\taction: 0,\n\t\t\t\tcollateralType: loan.collateralType,\n\t\t\t\tcollateralAddress: loan.collateralAddress,\n\t\t\t\tborrower: loan.borrower\n\t\t\t})\n\t\t);\n\n\t\temit CrosschainLoanBorrowedInit(\n\t\t\t_loanId,\n\t\t\tloan.borrower,\n\t\t\tloan.duration,\n\t\t\tloan.interestRate,\n\t\t\tloan.loanAmount,\n\t\t\tloan.collateralChainId,\n\t\t\tloan.collateralAddress,\n\t\t\tloan.collateralAmountOrId,\n\t\t\tloan.collateralType\n\t\t);\n\t}\n\n\t/**\n\t * @notice Starts a loan with crosschain collateral. This function should be called by the borrower after calling `initBorrowWhithCrosschainCollateral`.\n\t * @param _loanId ID of the loan.\n\t */\n\tfunction borrowWhithCrosschainCollateral(\n\t\tuint256 _loanId\n\t) external nonReentrant {\n\t\t// Verify that the loan is not active.\n\t\tLoan storage loan = loans[_loanId];\n\t\tif (loan.startTimestamp != 0) {\n\t\t\trevert LoanAlreadyBorrowed(_loanId);\n\t\t}\n\t\tif (loan.borrower != msg.sender) {\n\t\t\trevert WrongBorrower(msg.sender, loan.borrower);\n\t\t}\n\n\t\t// Verify if the collateral has been deposited.\n\t\tIMessengerSepolia.LoanData memory loanData = USER_MESSENGER.getLoanData(\n\t\t\t_loanId\n\t\t);\n\t\tif (loanData.lastAction == 0 && loanData.isSuccessful == false) {\n\t\t\trevert CollateralNotDeposited(_loanId);\n\t\t}\n\n\t\t// Approve loan amount to be transferred to borrower.\n\t\tUSER_SAFE.approveDelegateCreditGho(loan.borrower, loan.loanAmount);\n\n\t\t// Update loan start timestamp.\n\t\tloan.startTimestamp = block.timestamp;\n\t\tloan.isActive = true;\n\n\t\temit LoanStarted(_loanId, block.timestamp);\n\t}\n\n\t/**\n\t * @notice Repays a loan with crosschain collateral.\n\t * @param _loanId ID of the loan.\n\t */\n\tfunction repayLoanCrosschainCollateral(\n\t\tuint256 _loanId\n\t) external nonReentrant {\n\t\tLoan storage loan = loans[_loanId];\n\n\t\t// Verify that the loan is active.\n\t\tif (!loan.isActive) {\n\t\t\trevert LoanNotActive(_loanId);\n\t\t}\n\n\t\t// Verify that the borrower is the one repaying the loan.\n\t\tif (loan.borrower != msg.sender) {\n\t\t\trevert WrongBorrower(msg.sender, loan.borrower);\n\t\t}\n\n\t\t// Total interest to be paid.\n\t\tuint256 totalInterest = (loan.loanAmount * loan.interestRate) / 10000;\n\n\t\t// Total amount to be repaid (loan amount + interest)\n\t\tuint256 totalAmountToRepay = loan.loanAmount + totalInterest;\n\n\t\t// Transfer GHO tokens from borrower to safe.\n\t\tGHO_TOKEN.safeTransferFrom(\n\t\t\tmsg.sender,\n\t\t\taddress(USER_SAFE),\n\t\t\ttotalAmountToRepay\n\t\t);\n\n\t\t// Transfer collateral back to borrower.\n\t\tUSER_MESSENGER.sendRequest(\n\t\t\tloan.collateralChainId,\n\t\t\tmessengers[loan.collateralChainId],\n\t\t\tIMessengerSepolia.Request({\n\t\t\t\tloanId: _loanId,\n\t\t\t\tcollateralIdOrAmount: loan.collateralAmountOrId,\n\t\t\t\taction: 1,\n\t\t\t\tcollateralType: loan.collateralType,\n\t\t\t\tcollateralAddress: loan.collateralAddress,\n\t\t\t\tborrower: loan.borrower\n\t\t\t})\n\t\t);\n\n\t\t// Deactivate loan.\n\t\tloan.isActive = false;\n\n\t\temit LoanRepaid(_loanId, msg.sender, loan.loanAmount, totalInterest);\n\t}\n\n\t/**\n\t * @notice Liquidates a loan with crosschain collateral.\n\t * @param _loanId ID of the loan.\n\t * @param _receiver Address of the receiver.\n\t */\n\tfunction liquidateLoanWhithCrosschainCollateral(\n\t\tuint256 _loanId,\n\t\taddress _receiver\n\t) external nonReentrant {\n\t\tLoan storage loan = loans[_loanId];\n\n\t\t// Verify if the duration of the loan has passed.\n\t\tif (block.timestamp < loan.startTimestamp + loan.duration) {\n\t\t\trevert LoanStillActive(_loanId);\n\t\t}\n\n\t\t// Deactivate loan.\n\t\tloan.isActive = false;\n\n\t\t// Repay loan.\n\t\tGHO_TOKEN.safeTransferFrom(\n\t\t\tmsg.sender,\n\t\t\taddress(USER_SAFE),\n\t\t\tloan.loanAmount\n\t\t);\n\n\t\t// Seize collateral.\n\t\tUSER_MESSENGER.sendRequest(\n\t\t\tloan.collateralChainId,\n\t\t\tmessengers[loan.collateralChainId],\n\t\t\tIMessengerSepolia.Request({\n\t\t\t\tloanId: _loanId,\n\t\t\t\tcollateralIdOrAmount: loan.collateralAmountOrId,\n\t\t\t\taction: 2,\n\t\t\t\tcollateralType: loan.collateralType,\n\t\t\t\tcollateralAddress: loan.collateralAddress,\n\t\t\t\tborrower: _receiver // The receiver is the liquidator.\n\t\t\t})\n\t\t);\n\n\t\temit LoanLiquidated(\n\t\t\t_loanId,\n\t\t\tloan.borrower,\n\t\t\t_receiver,\n\t\t\tloan.loanAmount,\n\t\t\t(loan.loanAmount * loan.interestRate) / 10000\n\t\t);\n\t}\n\n\t/**\n\t * @notice Starts a loan.\n\t * @param _loanId ID of the loan.\n\t */\n\tfunction borrow(uint256 _loanId) external nonReentrant {\n\t\t// Verify that the loan is not active.\n\t\tLoan storage loan = loans[_loanId];\n\t\tif (loan.startTimestamp != 0) {\n\t\t\trevert LoanAlreadyBorrowed(_loanId);\n\t\t}\n\t\tif (loan.borrower != msg.sender) {\n\t\t\trevert WrongBorrower(msg.sender, loan.borrower);\n\t\t}\n\n\t\t// Transfer collateral to this contract.\n\t\tif (loan.collateralType == false) {\n\t\t\tIERC721(loan.collateralAddress).safeTransferFrom(\n\t\t\t\tmsg.sender,\n\t\t\t\taddress(USER_LOAN_SAFE),\n\t\t\t\tloan.collateralAmountOrId\n\t\t\t);\n\t\t} else {\n\t\t\tIERC20(loan.collateralAddress).safeTransferFrom(\n\t\t\t\tmsg.sender,\n\t\t\t\taddress(USER_LOAN_SAFE),\n\t\t\t\tloan.collateralAmountOrId\n\t\t\t);\n\t\t}\n\n\t\t// Approve loan amount to be transferred to borrower.\n\t\tUSER_SAFE.approveDelegateCreditGho(loan.borrower, loan.loanAmount);\n\n\t\t// Update loan start timestamp.\n\t\tloan.startTimestamp = block.timestamp;\n\t\tloan.isActive = true;\n\n\t\temit LoanStarted(_loanId, block.timestamp);\n\t}\n\n\t/**\n\t * @notice Repays a loan.\n\t * @param _loanId ID of the loan.\n\t */\n\tfunction repay(uint256 _loanId) external nonReentrant {\n\t\tLoan storage loan = loans[_loanId];\n\n\t\t// Verify that the loan is active.\n\t\tif (!loan.isActive) {\n\t\t\trevert LoanNotActive(_loanId);\n\t\t}\n\n\t\t// Total interest to be paid.\n\t\tuint256 totalInterest = (loan.loanAmount * loan.interestRate) / 10000;\n\n\t\t// Total amount to be repaid (loan amount + interest)\n\t\tuint256 totalAmountToRepay = loan.loanAmount + totalInterest;\n\n\t\t// Transfer GHO tokens from borrower to safe.\n\t\tGHO_TOKEN.safeTransferFrom(\n\t\t\tmsg.sender,\n\t\t\taddress(USER_SAFE),\n\t\t\ttotalAmountToRepay\n\t\t);\n\n\t\t// Transfer collateral back to borrower.\n\t\tUSER_LOAN_SAFE.sendBackCollateral(_loanId);\n\n\t\t// Deactivate loan.\n\t\tloan.isActive = false;\n\n\t\temit LoanRepaid(_loanId, msg.sender, loan.loanAmount, totalInterest);\n\t}\n\n\t/**\n\t * @notice Liquidates a loan.\n\t * @param _loanId ID of the loan.\n\t * @param _receiver Address of the receiver.\n\t */\n\tfunction liquidateLoan(\n\t\tuint256 _loanId,\n\t\taddress _receiver\n\t) external nonReentrant {\n\t\tLoan storage loan = loans[_loanId];\n\n\t\t// Verify if the duration of the loan has passed.\n\t\tif (block.timestamp < loan.startTimestamp + loan.duration) {\n\t\t\trevert LoanStillActive(_loanId);\n\t\t}\n\n\t\t// Deactivate loan.\n\t\tloan.isActive = false;\n\n\t\t// Repay loan.\n\t\tGHO_TOKEN.safeTransferFrom(\n\t\t\tmsg.sender,\n\t\t\taddress(USER_SAFE),\n\t\t\tloan.loanAmount\n\t\t);\n\n\t\t// Seize collateral.\n\t\tUSER_LOAN_SAFE.seizeCollateral(_loanId, _receiver);\n\n\t\temit LoanLiquidated(\n\t\t\t_loanId,\n\t\t\tloan.borrower,\n\t\t\t_receiver,\n\t\t\tloan.loanAmount,\n\t\t\t(loan.loanAmount * loan.interestRate) / 10000\n\t\t);\n\t}\n}\n"
    },
    "contracts/Sepolia/users/LoanSafeSepolia.sol": {
      "content": "// File: contracts/Sepolia/users/LoanSafeSepolia.sol\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC721Receiver } from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport { IERC721 } from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\nimport { ILoanManagerSepolia } from \"../interfaces/ILoanManagerSepolia.sol\";\nimport { ISafeSepolia } from \"../interfaces/ISafeSepolia.sol\";\nimport { ILoanSafeSepolia } from \"../interfaces/ILoanSafeSepolia.sol\";\n\n/**\n * @title LoanSafeSepolia Contract\n * @author GhoSafe Protocol\n * @notice Contract for safekeeping loans\n * @dev This contract should be deployed by the SafeSepolia contract.\n */\ncontract LoanSafeSepolia is ILoanSafeSepolia, IERC721Receiver {\n\tusing SafeERC20 for IERC20;\n\n\t/// @notice Loan manager contract.\n\tILoanManagerSepolia public immutable USER_LOAN_MANAGER;\n\n\t/**\n\t * @notice Constructor\n\t */\n\tconstructor() {\n\t\tUSER_LOAN_MANAGER = ILoanManagerSepolia(msg.sender);\n\t}\n\n\t/**\n\t * @notice Checks if the collateral of a loan is owned by the contract.\n\t * @param _loanId ID of the loan.\n\t * @return isValid True if the collateral is owned by the contract.\n\t */\n\tfunction checkLoanCollateral(\n\t\tuint256 _loanId\n\t) external view returns (bool isValid) {\n\t\tILoanManagerSepolia.Loan memory loan = USER_LOAN_MANAGER.getLoanData(\n\t\t\t_loanId\n\t\t);\n\n\t\tif (loan.isActive) {\n\t\t\tif (loan.collateralType == false) {\n\t\t\t\tif (\n\t\t\t\t\tIERC721(loan.collateralAddress).ownerOf(\n\t\t\t\t\t\tloan.collateralAmountOrId\n\t\t\t\t\t) == address(this)\n\t\t\t\t) {\n\t\t\t\t\tisValid = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (\n\t\t\t\t\tIERC20(loan.collateralAddress).balanceOf(address(this)) >=\n\t\t\t\t\tloan.collateralAmountOrId\n\t\t\t\t) {\n\t\t\t\t\tisValid = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @notice Sends back the collateral of a loan.\n\t * @param _loanId ID of the loan.\n\t */\n\tfunction sendBackCollateral(uint256 _loanId) external {\n\t\tif (msg.sender != address(USER_LOAN_MANAGER)) {\n\t\t\trevert UnauthorizedAccess(msg.sender);\n\t\t}\n\n\t\tILoanManagerSepolia.Loan memory loan = USER_LOAN_MANAGER.getLoanData(\n\t\t\t_loanId\n\t\t);\n\n\t\tif (loan.isActive) {\n\t\t\tif (loan.collateralType == false) {\n\t\t\t\tIERC721(loan.collateralAddress).safeTransferFrom(\n\t\t\t\t\taddress(this),\n\t\t\t\t\tloan.borrower,\n\t\t\t\t\tloan.collateralAmountOrId\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tIERC20(loan.collateralAddress).safeTransfer(\n\t\t\t\t\tloan.borrower,\n\t\t\t\t\tloan.collateralAmountOrId\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @notice Seizes the collateral of a loan.\n\t * @param _loanId ID of the loan.\n\t * @param _receiver Address of the receiver.\n\t */\n\tfunction seizeCollateral(uint256 _loanId, address _receiver) external {\n\t\tif (msg.sender != address(USER_LOAN_MANAGER)) {\n\t\t\trevert UnauthorizedAccess(msg.sender);\n\t\t}\n\n\t\tILoanManagerSepolia.Loan memory loan = USER_LOAN_MANAGER.getLoanData(\n\t\t\t_loanId\n\t\t);\n\n\t\tif (!loan.isActive) {\n\t\t\tif (loan.collateralType == false) {\n\t\t\t\tIERC721(loan.collateralAddress).safeTransferFrom(\n\t\t\t\t\taddress(this),\n\t\t\t\t\t_receiver,\n\t\t\t\t\tloan.collateralAmountOrId\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tIERC20(loan.collateralAddress).safeTransfer(\n\t\t\t\t\t_receiver,\n\t\t\t\t\tloan.collateralAmountOrId\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @dev The contract should be able to receive ERC721 tokens.\n\t */\n\tfunction onERC721Received(\n\t\taddress,\n\t\taddress,\n\t\tuint256,\n\t\tbytes calldata\n\t)\n\t\texternal\n\t\tpure\n\t\toverride(ILoanSafeSepolia, IERC721Receiver)\n\t\treturns (bytes4)\n\t{\n\t\treturn this.onERC721Received.selector;\n\t}\n}\n"
    },
    "contracts/Sepolia/users/MailboxSepolia.sol": {
      "content": "// File: contracts/Sepolia/users/MailBox.sol\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { IMailboxSepolia } from \"../interfaces/IMailboxSepolia.sol\";\nimport { IGhoSafeIDSepolia } from \"../interfaces/IGhoSafeIDSepolia.sol\";\n\n/**\n * @title MailboxSepolia Contract\n * @author GhoSafe Protocol\n * @notice Contract used by delegees to create loan requests\n * @dev This contract should be deployed by the SafeSepolia contract\n */\ncontract MailboxSepolia is IMailboxSepolia {\n\t/// @notice Loans request counter.\n\tuint256 public loanRequestsCounter;\n\n\t/// @notice Loans request mapping.\n\tmapping(uint256 => LoanRequest) public loanRequests;\n\n\t/// @notice GhoSafeID contract.\n\tIGhoSafeIDSepolia private immutable GHO_SAFE_ID;\n\n\t/// @notice Safe Address\n\taddress public immutable SAFE_ADDRESS;\n\n\t/**\n\t * @notice Constructor\n\t * @param _ghoSafeId Address of the GhoSafeID contract.\n\t */\n\tconstructor(address _ghoSafeId) {\n\t\tGHO_SAFE_ID = IGhoSafeIDSepolia(_ghoSafeId);\n\t\tSAFE_ADDRESS = msg.sender;\n\t}\n\n\t/**\n\t * @notice Returns the loan request.\n\t * @param _loanRequestId ID of the loan request.\n\t * @return loanRequestData Loan request struct.\n\t */\n\tfunction getLoanRequest(\n\t\tuint256 _loanRequestId\n\t) external view returns (LoanRequest memory loanRequestData) {\n\t\tloanRequestData = loanRequests[_loanRequestId];\n\t}\n\n\t/**\n\t * @notice Creates a loan request.\n\t * @param _collateralAmountOrId Amount or ID of the collateral asset.\n\t * @param _collateralAddress Address of the collateral asset.\n\t * @param _collateralType Type of the collateral asset: 0 for ERC20, 1 for ERC721.\n\t * @param _collateralChainId Chain ID of the collateral asset.\n\t * @param _amountToBorrow Amount of loan to borrow in GHO tokens.\n\t * @param _loanDuration Duration of the loan in seconds.\n\t * @return loanRequestId ID of the loan request.\n\t */\n\tfunction loanRequest(\n\t\tuint256 _collateralAmountOrId,\n\t\taddress _collateralAddress,\n\t\tbool _collateralType,\n\t\tuint64 _collateralChainId,\n\t\tuint256 _amountToBorrow,\n\t\tuint256 _loanDuration\n\t) external returns (uint256 loanRequestId) {\n\t\tif (GHO_SAFE_ID.balanceOf(msg.sender) == 0) {\n\t\t\trevert NoGhoSafeIDFound(msg.sender);\n\t\t}\n\t\tloanRequestId = loanRequestsCounter++;\n\t\tloanRequests[loanRequestId] = LoanRequest(\n\t\t\t_amountToBorrow,\n\t\t\t_loanDuration,\n\t\t\t_collateralAmountOrId,\n\t\t\t_collateralAddress,\n\t\t\tmsg.sender,\n\t\t\t_collateralChainId,\n\t\t\t_collateralType\n\t\t);\n\t\temit LoanRequestCreated(\n\t\t\tloanRequestId,\n\t\t\tmsg.sender,\n\t\t\t_collateralAmountOrId,\n\t\t\t_collateralAddress,\n\t\t\t_collateralChainId,\n\t\t\t_collateralType,\n\t\t\t_amountToBorrow,\n\t\t\t_loanDuration\n\t\t);\n\t}\n}\n"
    },
    "contracts/Sepolia/users/MessengerSepolia.sol": {
      "content": "// File: contracts/Sepolia/users/MessengerSepolia.sol\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { IRouterClient } from \"@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol\";\nimport { Client } from \"@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol\";\nimport { CCIPReceiver } from \"@chainlink/contracts-ccip/src/v0.8/ccip/applications/CCIPReceiver.sol\";\nimport { IERC20 } from \"@chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v4.8.0/contracts/token/ERC20/IERC20.sol\";\n\nimport { IMessengerSepolia } from \"../interfaces/IMessengerSepolia.sol\";\nimport { ILoanManagerSepolia } from \"../interfaces/ILoanManagerSepolia.sol\";\nimport { IAccessManagerSepolia } from \"../interfaces/IAccessManagerSepolia.sol\";\n\n/**\n * @title MessengerSepolia Contract\n * @author GhoSafe Protocol\n * @notice Contract for transferring messages between chains\n * @dev This contract should be deployed by the SafeSepolia contract.\n */\ncontract MessengerSepolia is IMessengerSepolia, CCIPReceiver {\n\t/// @notice Loan manager contract.\n\tILoanManagerSepolia public immutable USER_LOAN_MANAGER;\n\n\t/// @notice Access manager contract.\n\tIAccessManagerSepolia public immutable USER_ACCESS_MANAGER;\n\n\t/// @notice Mapping of message IDs to messages.\n\tmapping(bytes32 => string) public messageIdToText;\n\n\t/// @notice Mapping to keep track of allowlisted destination chains.\n\tmapping(uint64 => bool) public allowlistedDestinationChains;\n\n\t/// @notice Mapping to keep track of allowlisted source chains.\n\tmapping(uint64 => bool) public allowlistedSourceChains;\n\n\t/// @notice Mapping to keep track of allowlisted senders.\n\tmapping(address => bool) public allowlistedSenders;\n\n\t/// @dev Mapping of loan IDs to loan data.\n\tmapping(uint256 => LoanData) private loanData;\n\n\t/// @notice Link Token.\n\tIERC20 private LINK_TOKEN;\n\n\t/**\n\t * @notice Constructor initializes the contract with the router address.\n\t * @param _router The address of the router contract.\n\t * @param _link The address of the link contract.\n\t * @param _accessManager The address of the access manager contract.\n\t */\n\tconstructor(\n\t\taddress _router,\n\t\taddress _link,\n\t\tIAccessManagerSepolia _accessManager\n\t) CCIPReceiver(_router) {\n\t\tLINK_TOKEN = IERC20(_link);\n\t\tUSER_LOAN_MANAGER = ILoanManagerSepolia(msg.sender);\n\t\tUSER_ACCESS_MANAGER = _accessManager;\n\t}\n\n\t/**\n\t * @dev Modifier that checks if the chain with the given destinationChainSelector is allowlisted.\n\t * @param _destinationChainSelector The selector of the destination chain.\n\t */\n\tmodifier onlyAllowlistedDestinationChain(uint64 _destinationChainSelector) {\n\t\tif (!allowlistedDestinationChains[_destinationChainSelector])\n\t\t\trevert DestinationChainNotAllowlisted(_destinationChainSelector);\n\t\t_;\n\t}\n\n\t/**\n\t * @dev Modifier that checks if the chain with the given sourceChainSelector is allowlisted and if the sender is allowlisted.\n\t * @param _sourceChainSelector The selector of the destination chain.\n\t * @param _sender The address of the sender.\n\t */\n\tmodifier onlyAllowlisted(uint64 _sourceChainSelector, address _sender) {\n\t\tif (!allowlistedSourceChains[_sourceChainSelector])\n\t\t\trevert SourceChainNotAllowlisted(_sourceChainSelector);\n\t\tif (!allowlistedSenders[_sender]) revert SenderNotAllowlisted(_sender);\n\t\t_;\n\t}\n\n\t/**\n\t * @dev Modifier that checks if the sender is the owner.\n\t */\n\tmodifier onlyOwner() {\n\t\tif (!USER_ACCESS_MANAGER.hasRole(keccak256(\"OWNER_ROLE\"), msg.sender)) {\n\t\t\trevert OnlyOwnerCanCall(msg.sender);\n\t\t}\n\t\t_;\n\t}\n\n\t/**\n\t * @notice Returns the loan data for a given loan ID.\n\t * @param _loanId ID of the loan.\n\t * @return LoanData Loan data.\n\t */\n\tfunction getLoanData(\n\t\tuint256 _loanId\n\t) external view returns (LoanData memory) {\n\t\treturn loanData[_loanId];\n\t}\n\n\t/**\n\t * @notice Allows the contract owner to update the allowlist status of a destination chain for transactions.\n\t * @param _destinationChainSelector The identifier (aka selector) for the destination blockchain.\n\t * @param _allowed The new allowlist status.\n\t * @dev This function reverts if the sender is not the owner.\n\t */\n\tfunction allowlistDestinationChain(\n\t\tuint64 _destinationChainSelector,\n\t\tbool _allowed\n\t) external override onlyOwner {\n\t\tallowlistedDestinationChains[_destinationChainSelector] = _allowed;\n\t}\n\n\t/**\n\t * @notice Allows the contract owner to update the allowlist status of a source chain for transactions.\n\t * @param _sourceChainSelector The identifier (aka selector) for the source blockchain.\n\t * @param _allowed The new allowlist status.\n\t * @dev This function reverts if the sender is not the owner.\n\t */\n\tfunction allowlistSourceChain(\n\t\tuint64 _sourceChainSelector,\n\t\tbool _allowed\n\t) external override onlyOwner {\n\t\tallowlistedSourceChains[_sourceChainSelector] = _allowed;\n\t}\n\n\t/**\n\t * @notice Allows the contract owner to update the allowlist status of a sender for transactions.\n\t * @param _sender The address of the sender.\n\t * @param _allowed The new allowlist status.\n\t * @dev This function reverts if the sender is not the owner.\n\t */\n\tfunction allowlistSender(\n\t\taddress _sender,\n\t\tbool _allowed\n\t) external override onlyOwner {\n\t\tallowlistedSenders[_sender] = _allowed;\n\t}\n\n\t/**\n\t * @notice Send a collateral deposit request to another chain.\n\t * @dev The contract should have sufficient LINK.\n\t * @param _destinationChainSelector The identifier (aka selector) for the destination blockchain.\n\t * @param _receiver The address of the recipient on the destination blockchain.\n\t */\n\tfunction sendRequest(\n\t\tuint64 _destinationChainSelector,\n\t\taddress _receiver,\n\t\tRequest calldata _collateralDepositRequest\n\t) external onlyAllowlistedDestinationChain(_destinationChainSelector) {\n\t\t// Only the LoanManager contract can send messages\n\t\tif (msg.sender != address(USER_LOAN_MANAGER)) {\n\t\t\trevert OnlyLoanManagerCanCall(msg.sender);\n\t\t}\n\n\t\t// Encode the message struct into bytes\n\t\tbytes memory data = abi.encode(_collateralDepositRequest);\n\n\t\t// Create an EVM2AnyMessage struct in memory with necessary information for sending a cross-chain message\n\t\tClient.EVM2AnyMessage memory evm2AnyMessage = _buildCCIPMessage(\n\t\t\t_receiver,\n\t\t\tdata,\n\t\t\taddress(LINK_TOKEN)\n\t\t);\n\n\t\t// Initialize a router client instance to interact with cross-chain router\n\t\tIRouterClient router = IRouterClient(this.getRouter());\n\n\t\t// Get the fee required to send the CCIP message\n\t\tuint256 fees = router.getFee(_destinationChainSelector, evm2AnyMessage);\n\n\t\tif (fees > LINK_TOKEN.balanceOf(address(this)))\n\t\t\trevert NotEnoughBalance(LINK_TOKEN.balanceOf(address(this)), fees);\n\n\t\t// approve the Router to transfer LINK tokens on contract's behalf. It will spend the fees in LINK\n\t\tLINK_TOKEN.approve(address(router), fees);\n\n\t\t// Send the CCIP message through the router and store the returned CCIP message ID\n\t\tbytes32 lastSentMessageId = router.ccipSend(\n\t\t\t_destinationChainSelector,\n\t\t\tevm2AnyMessage\n\t\t);\n\n\t\t// Store data\n\t\tloanData[_collateralDepositRequest.loanId]\n\t\t\t.lastSentMessageId = lastSentMessageId;\n\t\tloanData[_collateralDepositRequest.loanId]\n\t\t\t.lastAction = _collateralDepositRequest.action;\n\n\t\t// Emit an event with message details\n\t\temit RequestSent(\n\t\t\tlastSentMessageId,\n\t\t\t_collateralDepositRequest.loanId,\n\t\t\t_collateralDepositRequest.collateralIdOrAmount,\n\t\t\t_destinationChainSelector,\n\t\t\t_collateralDepositRequest.action,\n\t\t\t_collateralDepositRequest.collateralType,\n\t\t\t_collateralDepositRequest.collateralAddress,\n\t\t\t_collateralDepositRequest.borrower\n\t\t);\n\t}\n\n\t/**\n\t * @dev This function is called by the router when a CCIP message is received.\n\t * @param any2EvmMessage Received message\n\t */\n\tfunction _ccipReceive(\n\t\tClient.Any2EVMMessage memory any2EvmMessage\n\t)\n\t\tinternal\n\t\toverride\n\t\tonlyAllowlisted(\n\t\t\tany2EvmMessage.sourceChainSelector,\n\t\t\tabi.decode(any2EvmMessage.sender, (address))\n\t\t) // Make sure source chain and sender are allowlisted\n\t{\n\t\t// Decode the data into a Response struct\n\t\tResponse memory response = abi.decode(any2EvmMessage.data, (Response));\n\n\t\t// Store data\n\t\tloanData[response.loanId].isSuccessful = response.isSuccessful;\n\t\tloanData[response.loanId].lastAction = response.action;\n\t\tloanData[response.loanId].lastReceivedMessageId = any2EvmMessage\n\t\t\t.messageId;\n\n\t\t// Emit an event with message details\n\t\temit MessageReceived(\n\t\t\tany2EvmMessage.messageId,\n\t\t\tany2EvmMessage.sourceChainSelector, // fetch the source chain identifier (aka selector)\n\t\t\tabi.decode(any2EvmMessage.sender, (address)), // abi-decoding of the sender address,\n\t\t\tresponse.loanId,\n\t\t\tresponse.action,\n\t\t\tresponse.isSuccessful\n\t\t);\n\t}\n\n\t/**\n\t * @notice Constructs a CCIP message.\n\t * @dev This function will create an EVM2AnyMessage struct with all the necessary information for sending a text.\n\t * @param _receiver The address of the receiver.\n\t * @param _data The bytes data to be sent.\n\t * @param _feeTokenAddress The address of the token used for fees. Set address(0) for native gas.\n\t * @return Client.EVM2AnyMessage Returns an EVM2AnyMessage struct which contains information for sending a CCIP message.\n\t */\n\tfunction _buildCCIPMessage(\n\t\taddress _receiver,\n\t\tbytes memory _data,\n\t\taddress _feeTokenAddress\n\t) internal pure returns (Client.EVM2AnyMessage memory) {\n\t\t// Create an EVM2AnyMessage struct in memory with necessary information for sending a cross-chain message\n\t\treturn\n\t\t\tClient.EVM2AnyMessage({\n\t\t\t\treceiver: abi.encode(_receiver), // ABI-encoded receiver address\n\t\t\t\tdata: _data, // Already encoded data\n\t\t\t\ttokenAmounts: new Client.EVMTokenAmount[](0), // Empty array aas no tokens are transferred\n\t\t\t\textraArgs: Client._argsToBytes(\n\t\t\t\t\t// Additional arguments, setting gas limit\n\t\t\t\t\tClient.EVMExtraArgsV1({ gasLimit: 200_000 })\n\t\t\t\t),\n\t\t\t\t// Set the feeToken to a feeTokenAddress, indicating specific asset will be used for fees\n\t\t\t\tfeeToken: _feeTokenAddress\n\t\t\t});\n\t}\n\n\t/**\n\t * @notice Allows the owner of the contract to withdraw all tokens of a specific ERC20 token.\n\t * @dev This function reverts with a 'NothingToWithdraw' error if there are no tokens to withdraw.\n\t * @param _beneficiary The address to which the tokens will be sent.\n\t * @param _token The contract address of the ERC20 token to be withdrawn.\n\t */\n\tfunction withdrawToken(\n\t\taddress _beneficiary,\n\t\taddress _token\n\t) public onlyOwner {\n\t\t// Retrieve the balance of this contract\n\t\tuint256 amount = IERC20(_token).balanceOf(address(this));\n\n\t\t// Revert if there is nothing to withdraw\n\t\tif (amount == 0) revert NothingToWithdraw();\n\n\t\tIERC20(_token).transfer(_beneficiary, amount);\n\t}\n}\n "
    },
    "contracts/Sepolia/users/SafeSepolia.sol": {
      "content": "// File: contracts/Sepolia/users/SafeSepolia.sol\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IPool } from \"@aave/core-v3/contracts/interfaces/IPool.sol\";\nimport { ICreditDelegationToken } from \"@aave/core-v3/contracts/interfaces/ICreditDelegationToken.sol\";\n\nimport { LoanManagerSepolia } from \"./LoanManagerSepolia.sol\";\nimport { MailboxSepolia } from \"./MailboxSepolia.sol\";\nimport { AccessManagerSepolia } from \"./AccessManagerSepolia.sol\";\nimport { IAccessManagerSepolia } from \"../interfaces/IAccessManagerSepolia.sol\";\nimport { ISafeSepolia } from \"../interfaces/ISafeSepolia.sol\";\n\n/**\n * @title SafeSepolia Contract\n * @author GhoSafe Protocol\n * @notice Walet contract for managing funds and interacting with Aave\n */\ncontract SafeSepolia is ISafeSepolia {\n\t/// @dev Aave's lending pool address on Sepolia: https://sepolia.etherscan.io/address/0x6Ae43d3271ff6888e7Fc43Fd7321a503ff738951\n\tIPool internal immutable AAVE_POOL;\n\n\t/// @dev GHO token address on Sepolia: https://sepolia.etherscan.io/address/0xc4bF5CbDaBE595361438F8c6a187bDc330539c60\n\tIERC20 internal immutable GHO_TOKEN;\n\n\t/// @dev Credit Delegation Token for GHO on Sepolia: https://sepolia.etherscan.io/address/0x67ae46EF043F7A4508BD1d6B94DB6c33F0915844\n\tICreditDelegationToken internal immutable DEBT_GHO_TOKEN;\n\n\t/// @notice Access manager contract.\n\tIAccessManagerSepolia public immutable USER_ACCESS_MANAGER;\n\n\t/// @notice Address of the LoanManager contract.\n\taddress public immutable USER_LOAN_MANAGER_ADDRESS;\n\n\t/// @notice Address of the Mailbox contract.\n\taddress public immutable USER_MAILBOX_ADDRESS;\n\n\t/// @notice Referral code for Aave interactions.\n\tuint16 public immutable REFERRAL_CODE;\n\n\t/**\n\t * @notice Constructor\n\t * @param _ghoSafeIDSepolia Address of the GhoSafeIDSepolia contract\n\t * @param _loanAdvertisementBook Address of the LoanAdvertisementBook contract\n\t * @param _referralCode Referral code for Aave interactions\n\t * @param _ghoToken Address of the GHO token\n\t * @param _debtGhoToken Address of the Credit Delegation Token for GHO\n\t * @param _pool Address of the Aave pool\n\t * @param _router Address of the router contract\n\t * @param _link Address of the LINK token\n\t * @param _owner Address of the owner\n\t */\n\tconstructor(\n\t\taddress _ghoSafeIDSepolia,\n\t\taddress _loanAdvertisementBook,\n\t\tuint16 _referralCode,\n\t\taddress _ghoToken,\n\t\taddress _debtGhoToken,\n\t\taddress _pool,\n\t\taddress _router,\n\t\taddress _link,\n\t\taddress _owner\n\t) {\n\t\tUSER_ACCESS_MANAGER = IAccessManagerSepolia(\n\t\t\taddress(new AccessManagerSepolia(_owner))\n\t\t);\n\t\tUSER_MAILBOX_ADDRESS = address(new MailboxSepolia(_ghoSafeIDSepolia));\n\t\tUSER_LOAN_MANAGER_ADDRESS = address(\n\t\t\tnew LoanManagerSepolia(\n\t\t\t\tUSER_ACCESS_MANAGER,\n\t\t\t\tUSER_MAILBOX_ADDRESS,\n\t\t\t\t_loanAdvertisementBook,\n\t\t\t\t_ghoToken,\n\t\t\t\t_debtGhoToken,\n\t\t\t\t_router,\n\t\t\t\t_link\n\t\t\t)\n\t\t);\n\t\tREFERRAL_CODE = _referralCode;\n\t\tAAVE_POOL = IPool(_pool);\n\t\tGHO_TOKEN = IERC20(_ghoToken);\n\t\tDEBT_GHO_TOKEN = ICreditDelegationToken(_debtGhoToken);\n\t}\n\n\t/// @dev Throws if called by any account other than the owner.\n\tmodifier onlyOwner() {\n\t\tif (!USER_ACCESS_MANAGER.hasRole(keccak256(\"OWNER_ROLE\"), msg.sender)) {\n\t\t\trevert UnauthorizedAccess(msg.sender);\n\t\t}\n\t\t_;\n\t}\n\n\t/**\n\t * @notice Returns the balances of the specified tokens\n\t * @param _tokens Addresses of the ERC20 tokens to check\n\t * @return balances Balances of the specified tokens\n\t */\n\tfunction getSafeBalances(\n\t\taddress[] calldata _tokens\n\t) external view returns (uint256[] memory balances) {\n\t\tbalances = new uint256[](_tokens.length);\n\t\tfor (uint256 i = 0; i < _tokens.length; i++) {\n\t\t\tbalances[i] = IERC20(_tokens[i]).balanceOf(address(this));\n\t\t}\n\t}\n\n\t/**\n\t * @notice Adds an owner to the contract.\n\t * @param _owner Address of the owner to add\n\t */\n\tfunction addOwner(address _owner) external onlyOwner {\n\t\tUSER_ACCESS_MANAGER.grantOwnerRole(_owner);\n\t\temit OwnerAdded(_owner);\n\t}\n\n\t/**\n\t * @notice Removes an owner from the contract.\n\t * @param _owner Address of the owner to remove\n\t */\n\tfunction removeOwner(address _owner) external onlyOwner {\n\t\tUSER_ACCESS_MANAGER.revokeOwnerRole(_owner);\n\t\temit OwnerRemoved(_owner);\n\t}\n\n\t/**\n\t * @notice Withdraws a specific amount of ETH from the contract to a specified address.\n\t * @param _to Address that will receive the ETH\n\t * @param _amount Amount of ETH to withdraw\n\t */\n\tfunction withdrawETHFromSafe(\n\t\taddress payable _to,\n\t\tuint256 _amount\n\t) external payable onlyOwner {\n\t\t// Check if the contract has enough ETH\n\t\tif (address(this).balance < _amount) {\n\t\t\trevert NotEnoughBalance(address(0), _amount, address(this).balance);\n\t\t}\n\n\t\t// Transfer the ETH to the specified address\n\t\t(bool sent, bytes memory data) = _to.call{ value: _amount }(\"\");\n\n\t\t// Revert if the transfer failed\n\t\tif (!sent) {\n\t\t\trevert ETHTtransferFailed(data);\n\t\t}\n\n\t\t// Emit event\n\t\temit ETHWithdrawnFromSafe(_amount, _to);\n\t}\n\n\t/**\n\t * @notice Withdraws a specific amount of an ERC20 token from the contract to a specified address.\n\t * @param _to Address that will receive the token\n\t * @param _token Address of the ERC20 token\n\t * @param _amount Amount of the token to withdraw\n\t */\n\tfunction withdrawFromSafe(\n\t\taddress payable _to,\n\t\taddress _token,\n\t\tuint256 _amount\n\t) external onlyOwner {\n\t\t// Check if the contract has enough tokens\n\t\tif (IERC20(_token).balanceOf(address(this)) < _amount) {\n\t\t\trevert NotEnoughBalance(\n\t\t\t\t_token,\n\t\t\t\t_amount,\n\t\t\t\tIERC20(_token).balanceOf(address(this))\n\t\t\t);\n\t\t}\n\n\t\t// Transfer the tokens to the specified address\n\t\tIERC20(_token).transfer(_to, _amount);\n\n\t\t// Emit event\n\t\temit ERC20WithdrawnFromSafe(_token, _amount, _to);\n\t}\n\n\t/**\n\t * @notice Supplies a specific amount of an ERC20 token to Aave.\n\t * @param _token Address of the ERC20 token\n\t * @param _amount Amount of the token to supply\n\t */\n\tfunction supplyToAave(address _token, uint256 _amount) external onlyOwner {\n\t\tif (IERC20(_token).balanceOf(address(this)) < _amount) {\n\t\t\trevert NotEnoughBalance(\n\t\t\t\t_token,\n\t\t\t\t_amount,\n\t\t\t\tIERC20(_token).balanceOf(address(this))\n\t\t\t);\n\t\t}\n\t\t// Approve the Aave pool to spend the token\n\t\tIERC20(_token).approve(address(AAVE_POOL), _amount);\n\n\t\t// Supply the token to Aave\n\t\tAAVE_POOL.supply(_token, _amount, address(this), REFERRAL_CODE);\n\n\t\t// Emit event\n\t\temit TokenSuppliedToAave(_token, _amount);\n\t}\n\n\t/**\n\t * @notice Withdraws a specific amount of an ERC20 token from Aave.\n\t * @param _token Address of the ERC20 token\n\t * @param _amount Amount of the token to withdraw\n\t */\n\tfunction withdrawFromAave(\n\t\taddress _token,\n\t\tuint256 _amount\n\t) external onlyOwner {\n\t\t// Withdraw the token from Aave\n\t\tAAVE_POOL.withdraw(_token, _amount, address(this));\n\n\t\t// Emit event\n\t\temit TokenWithdrawnFromAave(_token, _amount);\n\t}\n\n\t/**\n\t * @notice Borrows a specific amount of an ERC20 token from Aave.\n\t * @param _token Address of the ERC20 token\n\t * @param _amount Amount of the token to borrow\n\t * @param _interestRateMode Interest rate mode for the borrow\n\t */\n\tfunction borrowFromAave(\n\t\taddress _token,\n\t\tuint256 _amount,\n\t\tuint256 _interestRateMode\n\t) external onlyOwner {\n\t\t// Borrow the token from Aave\n\t\tAAVE_POOL.borrow(\n\t\t\t_token,\n\t\t\t_amount,\n\t\t\t_interestRateMode,\n\t\t\tREFERRAL_CODE,\n\t\t\taddress(this)\n\t\t);\n\n\t\t// Emit event\n\t\temit TokenBorrowedFromAave(_token, _amount);\n\t}\n\n\t/**\n\t * @notice Repays a specific amount of an ERC20 token to Aave.\n\t * @param _token Address of the ERC20 token\n\t * @param _amount Amount of the token to repay\n\t * @param _rateMode Interest rate mode for the repay\n\t */\n\tfunction repayToAave(\n\t\taddress _token,\n\t\tuint256 _amount,\n\t\tuint256 _rateMode\n\t) external onlyOwner {\n\t\t// Approve the Aave pool to spend the token\n\t\tIERC20(_token).approve(address(AAVE_POOL), _amount);\n\n\t\t// Repay the token to Aave\n\t\tAAVE_POOL.repay(_token, _amount, _rateMode, address(this));\n\n\t\t// Emit event\n\t\temit TokenRepaidToAave(_token, _amount);\n\t}\n\n\t/**\n\t * @notice Borrows GHO from Aave.\n\t * @param _amount Amount of GHO to borrow\n\t */\n\tfunction borrowGho(uint256 _amount) external onlyOwner {\n\t\t// Borrow GHO from Aave\n\t\tAAVE_POOL.borrow(\n\t\t\taddress(GHO_TOKEN),\n\t\t\t_amount,\n\t\t\t2,\n\t\t\tREFERRAL_CODE,\n\t\t\taddress(this)\n\t\t);\n\n\t\t// Emit event\n\t\temit TokenBorrowedFromAave(address(GHO_TOKEN), _amount);\n\t}\n\n\t/**\n\t * @notice Repays GHO to Aave.\n\t * @param _amount Amount of GHO to repay\n\t */\n\tfunction repayGho(uint256 _amount) external onlyOwner {\n\t\t// Approve the Aave pool to spend GHO\n\t\tIERC20(address(GHO_TOKEN)).approve(address(AAVE_POOL), _amount);\n\n\t\t// Repay GHO to Aave\n\t\tAAVE_POOL.repay(address(GHO_TOKEN), _amount, 2, address(this));\n\n\t\t// Emit event\n\t\temit TokenRepaidToAave(address(GHO_TOKEN), _amount);\n\t}\n\n\t/**\n\t * @notice Approves a delegatee to spend a specific amount of GHO.\n\t * @param _delegatee Address of the delegatee\n\t * @param _amount Amount of GHO to approve\n\t */\n\tfunction approveDelegateCreditGho(\n\t\taddress _delegatee,\n\t\tuint256 _amount\n\t) external {\n\t\t// Check if the caller is the LoanManager contract\n\t\tif (msg.sender != USER_LOAN_MANAGER_ADDRESS) {\n\t\t\trevert UnauthorizedAccess(msg.sender);\n\t\t}\n\n\t\t// Approve the delegatee to spend GHO\n\t\tDEBT_GHO_TOKEN.approveDelegation(_delegatee, _amount);\n\n\t\t// Emit event\n\t\temit CreditDelegateApproved(_delegatee, _amount);\n\t}\n\n\t/// @notice Fallback function to receive ETH with data\n\treceive() external payable {\n\t\temit ReceivedETH(msg.value, msg.sender);\n\t}\n\n\t/// @notice Fallback function to receive ETH without data\n\tfallback() external payable {\n\t\temit ReceivedETH(msg.value, msg.sender);\n\t}\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}